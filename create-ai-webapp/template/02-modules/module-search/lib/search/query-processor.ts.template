/**
 * ================================================================
 * AI Web App Template - æ™ºèƒ½æŸ¥è©¢è™•ç†å™¨ (lib/search/query-processor.ts)
 * ================================================================
 *
 * ã€æª”æ¡ˆåŠŸèƒ½ã€‘
 * é«˜ç´šè‡ªç„¶èªè¨€æŸ¥è©¢è™•ç†å¼•æ“,æä¾›æ™ºèƒ½æŸ¥è©¢ç†è§£ã€æ„åœ–è­˜åˆ¥å’Œèªç¾©æ“´å±•åŠŸèƒ½
 * æ”¯æ´ä¸­è‹±æ··åˆæŸ¥è©¢,å¯¦ç¾æŸ¥è©¢æ¨™æº–åŒ–ã€é—œéµè©æå–å’ŒåŒç¾©è©æ“´å±•
 *
 * ã€ä¸»è¦è·è²¬ã€‘
 * â€¢ æŸ¥è©¢è§£æåˆ†æ - èªè¨€æª¢æ¸¬ã€èªæ³•åˆ†æã€å¯¦é«”è­˜åˆ¥
 * â€¢ æ„åœ–è­˜åˆ¥å¼•æ“ - è‡ªå‹•è­˜åˆ¥ç”¨æˆ¶æœç´¢æ„åœ–å’Œéœ€æ±‚é¡å‹
 * â€¢ é—œéµè©æ™ºèƒ½æå– - å¤šå±¤æ¬¡é—œéµè©åˆ†é¡å’Œé‡è¦æ€§è©•åˆ†
 * â€¢ èªç¾©æŸ¥è©¢æ“´å±• - åŒç¾©è©ã€ç›¸é—œè©ã€èªç¾©è¯æƒ³æ“´å±•
 * â€¢ æŸ¥è©¢å„ªåŒ–é‡å¯« - æ‹¼å¯«ç³¾æ­£ã€æ¨™æº–åŒ–ã€æŸ¥è©¢å»ºè­°
 *
 * ã€æŠ€è¡“å¯¦ç¾ã€‘
 * â€¢ NLPæ¼”ç®—æ³• - è©æ€§æ¨™æ³¨ã€å¯¦é«”è­˜åˆ¥ã€èªç¾©åˆ†æ
 * â€¢ æ©Ÿå™¨å­¸ç¿’ - æ„åœ–åˆ†é¡ã€ç›¸ä¼¼åº¦è¨ˆç®—ã€æ¨¡å¼è­˜åˆ¥
 * â€¢ èªè¨€æ¨¡å‹ - å¤šèªè¨€æ”¯æ´ã€èªç¾©å‘é‡åŒ–
 * â€¢ çŸ¥è­˜åœ–è­œ - å¯¦é«”é—œè¯ã€æ¦‚å¿µæ“´å±•ã€é ˜åŸŸçŸ¥è­˜
 * â€¢ è¦å‰‡å¼•æ“ - èªæ³•è¦å‰‡ã€æ¥­å‹™è¦å‰‡ã€éæ¿¾é‚è¼¯
 *
 * ã€æŸ¥è©¢è™•ç†æµç¨‹ã€‘
 * 1. é è™•ç†ï¼šæ¸…ç†ã€æ¨™æº–åŒ–ã€èªè¨€æª¢æ¸¬
 * 2. èªæ³•åˆ†æï¼šåˆ†è©ã€è©æ€§æ¨™æ³¨ã€å¥æ³•è§£æ
 * 3. å¯¦é«”è­˜åˆ¥ï¼šå‘½åå¯¦é«”ã€æ™‚é–“ã€åœ°é»ã€æ¦‚å¿µ
 * 4. æ„åœ–åˆ†é¡ï¼šæœç´¢ç›®çš„ã€æŸ¥è©¢é¡å‹ã€æ¥­å‹™å ´æ™¯
 * 5. é—œéµè©æå–ï¼šä¸»è¦è©å½™ã€ä¿®é£¾è©ã€æŠ€è¡“è¡“èª
 * 6. èªç¾©æ“´å±•ï¼šåŒç¾©è©ã€ç›¸é—œè©ã€æ¦‚å¿µè¯æƒ³
 * 7. æŸ¥è©¢é‡å¯«ï¼šå„ªåŒ–è¡¨é”ã€ç³¾éŒ¯ã€å»ºè­°
 *
 * ã€æ™ºèƒ½ç‰¹æ€§ã€‘
 * â€¢ ä¸Šä¸‹æ–‡ç†è§£ï¼šåŸºæ–¼å°è©±æ­·å²å’Œç”¨æˆ¶è¡Œç‚º
 * â€¢ é ˜åŸŸé©æ‡‰ï¼šé‡å°æ¥­å‹™é ˜åŸŸå„ªåŒ–
 * â€¢ å­¸ç¿’èƒ½åŠ›ï¼šå¾ç”¨æˆ¶åé¥‹ä¸­æŒçºŒæ”¹é€²
 * â€¢ å¤šæ¨¡æ…‹æ”¯æ´ï¼šæ–‡æœ¬ã€èªéŸ³ã€åœ–åƒæŸ¥è©¢
 *
 * ã€ç›¸é—œæª”æ¡ˆã€‘
 * â€¢ å‘é‡æœç´¢: lib/search/vector-search.ts
 * â€¢ AIåµŒå…¥: lib/ai/embeddings.ts
 * â€¢ ç·©å­˜ç³»çµ±: lib/cache/query-cache.ts
 */

// æŸ¥è©¢æ„åœ–é¡å‹
export type SearchIntent =
  | 'specific_document'    // å°‹æ‰¾ç‰¹å®šæ–‡æª”
  | 'category_browse'      // ç€è¦½åˆ†é¡
  | 'concept_learning'     // æ¦‚å¿µå­¸ç¿’
  | 'how_to_guide'         // æ“ä½œæŒ‡å—
  | 'troubleshooting'      // å•é¡Œè§£æ±º
  | 'comparison'           // æ¯”è¼ƒåˆ†æ
  | 'latest_updates'       // æœ€æ–°æ›´æ–°
  | 'general_search'       // ä¸€èˆ¬æœç´¢

// æ–‡æª”åˆ†é¡æšèˆ‰ (å¯æ ¹æ“šæ¥­å‹™éœ€æ±‚è‡ªå®šç¾©)
export type DocumentCategory =
  | 'PRODUCT'
  | 'SALES'
  | 'TECHNICAL'
  | 'LEGAL'
  | 'TRAINING'
  | 'FAQ'
  | 'CASE_STUDY'
  | 'WHITE_PAPER'
  | 'PRESENTATION'
  | 'COMPETITOR'
  | 'NEWS'
  | 'OTHER'

// è§£æå¾Œçš„æŸ¥è©¢çµæ§‹
export interface ParsedQuery {
  originalQuery: string
  cleanedQuery: string
  keywords: string[]
  entities: QueryEntity[]
  intent: SearchIntent
  confidence: number
  language: 'zh-TW' | 'zh-CN' | 'en' | 'mixed'
  suggestions: QuerySuggestion[]
  filters: QueryFilters
}

// æŸ¥è©¢å¯¦é«”
export interface QueryEntity {
  text: string
  type: 'product' | 'category' | 'author' | 'date' | 'technology' | 'process'
  confidence: number
  start: number
  end: number
}

// æŸ¥è©¢å»ºè­°
export interface QuerySuggestion {
  text: string
  type: 'spelling' | 'synonym' | 'expansion' | 'related'
  confidence: number
}

// æŸ¥è©¢éæ¿¾å™¨
export interface QueryFilters {
  categories?: DocumentCategory[]
  dateRange?: {
    from?: Date
    to?: Date
  }
  authors?: string[]
  tags?: string[]
  fileTypes?: string[]
}

// é—œéµè©æå–çµæœ
export interface ExtractedKeywords {
  primary: string[]      // ä¸»è¦é—œéµè©
  secondary: string[]    // æ¬¡è¦é—œéµè©
  technical: string[]    // æŠ€è¡“è¡“èª
  entities: string[]     // å¯¦é«”è©å½™
  modifiers: string[]    // ä¿®é£¾è©
}

/**
 * æ™ºèƒ½æŸ¥è©¢è™•ç†å™¨é¡
 */
export class QueryProcessor {
  private stopWords: Set<string> = new Set()
  private synonyms: Map<string, string[]> = new Map()
  private technicalTerms: Set<string> = new Set()
  private categoryKeywords: Map<string, DocumentCategory> = new Map()

  constructor() {
    this.initializeStopWords()
    this.initializeSynonyms()
    this.initializeTechnicalTerms()
    this.initializeCategoryKeywords()
  }

  /**
   * è§£ææŸ¥è©¢ - æ ¸å¿ƒè‡ªç„¶èªè¨€è™•ç†å…¥å£
   *
   * ã€è™•ç†æµç¨‹ã€‘
   * åŸ·è¡Œå®Œæ•´çš„æŸ¥è©¢åˆ†æç®¡é“,å¾åŸå§‹æ–‡æœ¬åˆ°çµæ§‹åŒ–æŸ¥è©¢å°è±¡
   * é›†æˆå¤šå€‹NLPæŠ€è¡“å¯¦ç¾æ™ºèƒ½æŸ¥è©¢ç†è§£
   *
   * ã€åˆ†æç¶­åº¦ã€‘
   * â€¢ èªè¨€ç‰¹å¾µï¼šèªè¨€é¡å‹ã€æ–¹è¨€è­˜åˆ¥ã€æ··åˆèªè¨€è™•ç†
   * â€¢ èªæ³•çµæ§‹ï¼šè©æ€§æ¨™æ³¨ã€å¥æ³•åˆ†æã€ä¾å­˜é—œä¿‚
   * â€¢ èªç¾©å…§å®¹ï¼šæ¦‚å¿µæå–ã€é—œä¿‚è­˜åˆ¥ã€æ„åœ–åˆ†é¡
   * â€¢ å¯¦é«”ä¿¡æ¯ï¼šå‘½åå¯¦é«”ã€æ™‚é–“è¡¨é”ã€æ•¸å€¼ä¿¡æ¯
   * â€¢ æŸ¥è©¢æ„åœ–ï¼šæœç´¢ç›®çš„ã€æ¥­å‹™å ´æ™¯ã€å„ªå…ˆç´š
   *
   * ã€æ™ºèƒ½å„ªåŒ–ã€‘
   * â€¢ ä¸Šä¸‹æ–‡æ„ŸçŸ¥ï¼šè€ƒæ…®æ­·å²æŸ¥è©¢å’Œç”¨æˆ¶åå¥½
   * â€¢ é ˜åŸŸé©æ‡‰ï¼šé‡å°æ¥­å‹™é ˜åŸŸå°ˆé–€å„ªåŒ–
   * â€¢ ç³¾éŒ¯å»ºè­°ï¼šè‡ªå‹•ç™¼ç¾ä¸¦ä¿®æ­£æ‹¼å¯«éŒ¯èª¤
   * â€¢ æŸ¥è©¢æ“´å±•ï¼šåŒç¾©è©å’Œç›¸é—œæ¦‚å¿µè£œå……
   *
   * ã€è¼¸å‡ºçµæ§‹ã€‘
   * â€¢ æ¨™æº–åŒ–æŸ¥è©¢ï¼šæ¸…ç†å¾Œçš„è¦ç¯„åŒ–æ–‡æœ¬
   * â€¢ é—œéµè©é›†åˆï¼šæŒ‰é‡è¦æ€§åˆ†å±¤çš„è©å½™
   * â€¢ å¯¦é«”åˆ—è¡¨ï¼šè­˜åˆ¥çš„å‘½åå¯¦é«”å’Œå±¬æ€§
   * â€¢ æ„åœ–åˆ†é¡ï¼šæŸ¥è©¢ç›®çš„å’Œä¿¡å¿ƒåº¦è©•åˆ†
   * â€¢ éæ¿¾æ¢ä»¶ï¼šéš±å¼æå–çš„æœç´¢éæ¿¾å™¨
   * â€¢ æ”¹é€²å»ºè­°ï¼šæŸ¥è©¢å„ªåŒ–å’ŒåŒç¾©è©å»ºè­°
   *
   * @param query åŸå§‹æŸ¥è©¢å­—ä¸²
   * @returns Promise<ParsedQuery> çµæ§‹åŒ–æŸ¥è©¢åˆ†æçµæœ
   */
  async parseQuery(query: string): Promise<ParsedQuery> {
    // 1. æ¸…ç†å’Œæ­£è¦åŒ–æŸ¥è©¢
    const cleanedQuery = this.cleanQuery(query)

    // 2. æª¢æ¸¬èªè¨€
    const language = this.detectLanguage(cleanedQuery)

    // 3. æå–é—œéµè©
    const keywords = await this.extractKeywords(cleanedQuery)

    // 4. è­˜åˆ¥å¯¦é«”
    const entities = this.extractEntities(cleanedQuery)

    // 5. æª¢æ¸¬æŸ¥è©¢æ„åœ–
    const { intent, confidence } = this.detectIntent(cleanedQuery, keywords.primary, entities)

    // 6. ç”ŸæˆæŸ¥è©¢å»ºè­°
    const suggestions = await this.generateQuerySuggestions(cleanedQuery, keywords.primary)

    // 7. æå–éš±å¼éæ¿¾å™¨
    const filters = this.extractFilters(cleanedQuery, entities)

    return {
      originalQuery: query,
      cleanedQuery,
      keywords: keywords.primary,
      entities,
      intent,
      confidence,
      language,
      suggestions,
      filters
    }
  }

  /**
   * æ“´å±•æŸ¥è©¢ - åŸºæ–¼åŒç¾©è©å’Œç›¸é—œè©å½™
   */
  async expandQuery(query: string): Promise<string[]> {
    const cleanedQuery = this.cleanQuery(query)
    const keywords = await this.extractKeywords(cleanedQuery)
    const expansions: Set<string> = new Set([cleanedQuery])

    // 1. åŒç¾©è©æ“´å±•
    keywords.primary.forEach(keyword => {
      const synonyms = this.synonyms.get(keyword.toLowerCase())
      if (synonyms) {
        synonyms.forEach(synonym => {
          expansions.add(cleanedQuery.replace(keyword, synonym))
        })
      }
    })

    // 2. æŠ€è¡“è¡“èªæ“´å±•
    keywords.technical.forEach(term => {
      const relatedTerms = this.getRelatedTechnicalTerms(term)
      relatedTerms.forEach(relatedTerm => {
        expansions.add(cleanedQuery + ' ' + relatedTerm)
      })
    })

    // 3. èªç¾©æ“´å±•ï¼ˆå¯é¸ï¼šåŸºæ–¼å‘é‡ç›¸ä¼¼åº¦ï¼‰
    try {
      const semanticExpansions = await this.generateSemanticExpansions(cleanedQuery)
      semanticExpansions.forEach(expansion => expansions.add(expansion))
    } catch (error) {
      console.warn('Failed to generate semantic expansions:', error)
    }

    return Array.from(expansions).slice(0, 10) // é™åˆ¶æ“´å±•æ•¸é‡
  }

  /**
   * æª¢æ¸¬æŸ¥è©¢æ„åœ– (å…¬å…±æ¥å£)
   */
  async detectQueryIntent(query: string): Promise<SearchIntent> {
    const { intent } = this.detectIntent(query, [], [])
    return intent
  }

  /**
   * æå–é—œéµè© (å…¬å…±æ¥å£)
   */
  async extractQueryKeywords(query: string): Promise<string[]> {
    const keywords = await this.extractKeywords(query)
    return keywords.primary
  }

  /**
   * æ¸…ç†æŸ¥è©¢å­—ç¬¦ä¸²
   */
  private cleanQuery(query: string): string {
    return query
      .trim()
      .replace(/\s+/g, ' ')                    // åˆä½µå¤šå€‹ç©ºæ ¼
      .replace(/[^\w\s\u4e00-\u9fff]/g, ' ')   // ç§»é™¤ç‰¹æ®Šå­—ç¬¦,ä¿ç•™ä¸­æ–‡
      .toLowerCase()
  }

  /**
   * æª¢æ¸¬æŸ¥è©¢èªè¨€
   */
  private detectLanguage(query: string): 'zh-TW' | 'zh-CN' | 'en' | 'mixed' {
    const chineseChars = (query.match(/[\u4e00-\u9fff]/g) || []).length
    const englishChars = (query.match(/[a-zA-Z]/g) || []).length
    const totalChars = chineseChars + englishChars

    if (totalChars === 0) return 'mixed'

    const chineseRatio = chineseChars / totalChars

    if (chineseRatio > 0.8) {
      // æª¢æ¸¬ç¹é«”/ç°¡é«”ï¼ˆç°¡åŒ–ç‰ˆï¼‰
      const traditionalChars = ['æœƒ', 'å­¸', 'ç¶“', 'æ¥­', 'å¯¦', 'å•', 'é—œ', 'é–‹', 'è³‡', 'å°ˆ']
      const simplifiedChars = ['ä¼š', 'å­¦', 'ç»', 'ä¸š', 'å®', 'é—®', 'å…³', 'å¼€', 'èµ„', 'ä¸“']

      const hasTraditional = traditionalChars.some(char => query.includes(char))
      const hasSimplified = simplifiedChars.some(char => query.includes(char))

      if (hasTraditional && !hasSimplified) return 'zh-TW'
      if (hasSimplified && !hasTraditional) return 'zh-CN'
      return 'zh-TW' // é»˜èªç¹é«”
    }

    if (chineseRatio < 0.2) return 'en'

    return 'mixed'
  }

  /**
   * æå–é—œéµè© - å¢å¼·ç‰ˆ
   */
  private async extractKeywords(query: string): Promise<ExtractedKeywords> {
    const words = query.split(/\s+/).filter(word =>
      word.length > 1 && !this.stopWords.has(word)
    )

    const primary: string[] = []
    const secondary: string[] = []
    const technical: string[] = []
    const entities: string[] = []
    const modifiers: string[] = []

    words.forEach(word => {
      // æŠ€è¡“è¡“èª
      if (this.technicalTerms.has(word)) {
        technical.push(word)
        primary.push(word)
      }
      // åˆ†é¡é—œéµè©
      else if (this.categoryKeywords.has(word)) {
        entities.push(word)
        primary.push(word)
      }
      // ä¿®é£¾è©
      else if (this.isModifier(word)) {
        modifiers.push(word)
        secondary.push(word)
      }
      // ä¸»è¦é—œéµè©
      else if (word.length > 2) {
        primary.push(word)
      }
      // æ¬¡è¦é—œéµè©
      else {
        secondary.push(word)
      }
    })

    return {
      primary: [...new Set(primary)],
      secondary: [...new Set(secondary)],
      technical: [...new Set(technical)],
      entities: [...new Set(entities)],
      modifiers: [...new Set(modifiers)]
    }
  }

  /**
   * æå–æŸ¥è©¢å¯¦é«”
   */
  private extractEntities(query: string): QueryEntity[] {
    const entities: QueryEntity[] = []

    // æå–æ—¥æœŸå¯¦é«”
    const datePatterns = [
      /(\d{4}å¹´\d{1,2}æœˆ)/g,
      /(\d{4}-\d{1,2}-\d{1,2})/g,
      /(æœ€è¿‘|ä»Šå¤©|æ˜¨å¤©|æœ¬é€±|æœ¬æœˆ|å»å¹´)/g
    ]

    datePatterns.forEach(pattern => {
      let match
      while ((match = pattern.exec(query)) !== null) {
        entities.push({
          text: match[1],
          type: 'date',
          confidence: 0.9,
          start: match.index,
          end: match.index + match[1].length
        })
      }
    })

    // æå–ç”¢å“/æŠ€è¡“å¯¦é«”
    const productPattern = /(API|SDK|å¹³å°|ç³»çµ±|å·¥å…·|è»Ÿé«”|æ‡‰ç”¨|æœå‹™)/g
    let match
    while ((match = productPattern.exec(query)) !== null) {
      entities.push({
        text: match[1],
        type: 'technology',
        confidence: 0.8,
        start: match.index,
        end: match.index + match[1].length
      })
    }

    // æå–æµç¨‹å¯¦é«”
    const processPattern = /(å®‰è£|é…ç½®|è¨­ç½®|éƒ¨ç½²|æ¸¬è©¦|é–‹ç™¼|ç¶­è­·|å‡ç´š)/g
    while ((match = processPattern.exec(query)) !== null) {
      entities.push({
        text: match[1],
        type: 'process',
        confidence: 0.7,
        start: match.index,
        end: match.index + match[1].length
      })
    }

    return entities
  }

  /**
   * æª¢æ¸¬æŸ¥è©¢æ„åœ– - å…§éƒ¨å¯¦ç¾
   */
  private detectIntent(
    query: string,
    keywords: string[],
    entities: QueryEntity[]
  ): { intent: SearchIntent; confidence: number } {
    const intentPatterns: { pattern: RegExp; intent: SearchIntent; confidence: number }[] = [
      { pattern: /å¦‚ä½•|æ€éº¼|æ€æ¨£|how to|how do/i, intent: 'how_to_guide', confidence: 0.9 },
      { pattern: /æœ€æ–°|æ›´æ–°|latest|recent|new/i, intent: 'latest_updates', confidence: 0.8 },
      { pattern: /å•é¡Œ|éŒ¯èª¤|æ•…éšœ|error|issue|problem/i, intent: 'troubleshooting', confidence: 0.8 },
      { pattern: /æ¯”è¼ƒ|å°æ¯”|å·®ç•°|compare|difference|vs/i, intent: 'comparison', confidence: 0.8 },
      { pattern: /å­¸ç¿’|æ•™ç¨‹|tutorial|learn|guide/i, intent: 'concept_learning', confidence: 0.7 },
      { pattern: /åˆ†é¡|é¡åˆ¥|category|type/i, intent: 'category_browse', confidence: 0.6 }
    ]

    // æª¢æŸ¥ç‰¹å®šæ–‡æª”æ¨¡å¼
    if (query.includes('æ–‡æª”') || query.includes('document') || entities.some(e => e.type === 'product')) {
      return { intent: 'specific_document', confidence: 0.8 }
    }

    // æŒ‰å„ªå…ˆç´šæª¢æŸ¥æ„åœ–æ¨¡å¼
    for (const { pattern, intent, confidence } of intentPatterns) {
      if (pattern.test(query)) {
        return { intent, confidence }
      }
    }

    return { intent: 'general_search', confidence: 0.5 }
  }

  /**
   * ç”ŸæˆæŸ¥è©¢å»ºè­°
   */
  private async generateQuerySuggestions(query: string, keywords: string[]): Promise<QuerySuggestion[]> {
    const suggestions: QuerySuggestion[] = []

    // 1. æ‹¼å¯«å»ºè­°ï¼ˆç°¡åŒ–å¯¦ç¾ï¼‰
    const spellingErrors = this.detectSpellingErrors(query)
    spellingErrors.forEach(correction => {
      suggestions.push({
        text: correction,
        type: 'spelling',
        confidence: 0.8
      })
    })

    // 2. åŒç¾©è©å»ºè­°
    keywords.forEach(keyword => {
      const synonyms = this.synonyms.get(keyword.toLowerCase())
      if (synonyms) {
        synonyms.slice(0, 2).forEach(synonym => {
          suggestions.push({
            text: query.replace(keyword, synonym),
            type: 'synonym',
            confidence: 0.7
          })
        })
      }
    })

    // 3. æ“´å±•å»ºè­°
    const expansions = [
      `${query} æ•™ç¨‹`,
      `${query} æ–‡æª”`,
      `${query} ç¯„ä¾‹`,
      `å¦‚ä½• ${query}`,
      `${query} æœ€æ–°`
    ]

    expansions.slice(0, 3).forEach(expansion => {
      suggestions.push({
        text: expansion,
        type: 'expansion',
        confidence: 0.6
      })
    })

    return suggestions.slice(0, 8) // é™åˆ¶å»ºè­°æ•¸é‡
  }

  /**
   * æå–éš±å¼éæ¿¾å™¨
   */
  private extractFilters(query: string, entities: QueryEntity[]): QueryFilters {
    const filters: QueryFilters = {}

    // æå–åˆ†é¡éæ¿¾å™¨
    const categories: DocumentCategory[] = []
    this.categoryKeywords.forEach((category, keyword) => {
      if (query.includes(keyword)) {
        categories.push(category)
      }
    })
    if (categories.length > 0) {
      filters.categories = categories
    }

    // æå–æ—¥æœŸéæ¿¾å™¨
    const dateEntities = entities.filter(e => e.type === 'date')
    if (dateEntities.length > 0) {
      filters.dateRange = this.parseDateRange(dateEntities[0].text)
    }

    // æå–æ–‡ä»¶é¡å‹éæ¿¾å™¨
    const fileTypePattern = /\.(pdf|doc|docx|txt|md)/gi
    const fileTypeMatch = query.match(fileTypePattern)
    if (fileTypeMatch) {
      filters.fileTypes = fileTypeMatch.map(type => type.substring(1))
    }

    return filters
  }

  /**
   * ç”Ÿæˆèªç¾©æ“´å±•
   */
  private async generateSemanticExpansions(query: string): Promise<string[]> {
    // é€™è£¡å¯ä»¥ä½¿ç”¨ AI embeddings ä¾†ç”Ÿæˆèªç¾©ç›¸é—œçš„æŸ¥è©¢æ“´å±•
    // ç›®å‰è¿”å›åŸºæ–¼è¦å‰‡çš„æ“´å±•
    return [
      `${query} ç›¸é—œ`,
      `${query} é¡ä¼¼`,
      `é—œæ–¼ ${query}`
    ]
  }

  /**
   * ç²å–ç›¸é—œæŠ€è¡“è¡“èª
   */
  private getRelatedTechnicalTerms(term: string): string[] {
    const relatedTermsMap: { [key: string]: string[] } = {
      'api': ['æ¥å£', 'endpoint', 'rest', 'graphql'],
      'sdk': ['é–‹ç™¼åŒ…', 'library', 'å·¥å…·åŒ…'],
      'æ•¸æ“šåº«': ['database', 'sql', 'nosql', 'è³‡æ–™åº«'],
      'èªè­‰': ['authentication', 'oauth', 'jwt', 'æ¬Šé™'],
      'éƒ¨ç½²': ['deployment', 'docker', 'kubernetes', 'ç™¼å¸ƒ']
    }

    return relatedTermsMap[term.toLowerCase()] || []
  }

  /**
   * æª¢æ¸¬æ‹¼å¯«éŒ¯èª¤ï¼ˆç°¡åŒ–å¯¦ç¾ï¼‰
   */
  private detectSpellingErrors(query: string): string[] {
    // ç°¡åŒ–å¯¦ç¾ï¼šå¸¸è¦‹æ‹¼å¯«éŒ¯èª¤å°ç…§
    const corrections: { [key: string]: string } = {
      'apiæ¥å£': 'APIæ¥å£',
      'sdké–‹ç™¼': 'SDKé–‹ç™¼',
      'æ•°æ®åº“': 'è³‡æ–™åº«',
      'è®¤è¯': 'èªè­‰'
    }

    const corrected = Object.keys(corrections).find(error =>
      query.includes(error)
    )

    if (corrected) {
      return [query.replace(corrected, corrections[corrected])]
    }

    return []
  }

  /**
   * æª¢æŸ¥æ˜¯å¦ç‚ºä¿®é£¾è©
   */
  private isModifier(word: string): boolean {
    const modifiers = ['å¦‚ä½•', 'æ€éº¼', 'ä»€éº¼', 'å“ªå€‹', 'ç‚ºä»€éº¼', 'æœ€æ–°', 'æœ€å¥½', 'æ¨è–¦']
    return modifiers.includes(word)
  }

  /**
   * è§£ææ—¥æœŸç¯„åœ
   */
  private parseDateRange(dateText: string): { from?: Date; to?: Date } {
    const now = new Date()

    if (dateText.includes('æœ€è¿‘')) {
      return {
        from: new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000), // 7å¤©å‰
        to: now
      }
    }

    if (dateText.includes('æœ¬æœˆ')) {
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1)
      return {
        from: startOfMonth,
        to: now
      }
    }

    if (dateText.includes('å»å¹´')) {
      const lastYear = now.getFullYear() - 1
      return {
        from: new Date(lastYear, 0, 1),
        to: new Date(lastYear, 11, 31)
      }
    }

    // å…·é«”æ—¥æœŸè§£æï¼ˆç°¡åŒ–å¯¦ç¾ï¼‰
    const dateMatch = dateText.match(/(\d{4})-(\d{1,2})-(\d{1,2})/)
    if (dateMatch) {
      const date = new Date(
        parseInt(dateMatch[1]),
        parseInt(dateMatch[2]) - 1,
        parseInt(dateMatch[3])
      )
      return { from: date, to: date }
    }

    return {}
  }

  /**
   * åˆå§‹åŒ–åœç”¨è©
   */
  private initializeStopWords(): void {
    this.stopWords = new Set([
      // ä¸­æ–‡åœç”¨è©
      'çš„', 'äº†', 'æ˜¯', 'åœ¨', 'æœ‰', 'å’Œ', 'å°±', 'ä¸', 'äºº', 'éƒ½', 'ä¸€', 'å€‹', 'ä¸Š', 'ä¹Ÿ', 'å¾ˆ', 'åˆ°', 'èªª', 'è¦', 'å»', 'ä½ ', 'æœƒ', 'ç€', 'æ²’æœ‰', 'çœ‹', 'å¥½', 'è‡ªå·±', 'é€™', 'é‚£', 'å®ƒ', 'æˆ‘', 'ä»–',

      // è‹±æ–‡åœç”¨è©
      'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should'
    ])
  }

  /**
   * åˆå§‹åŒ–åŒç¾©è©åº«
   */
  private initializeSynonyms(): void {
    this.synonyms = new Map([
      ['æ–‡æª”', ['æ–‡ä»¶', 'è³‡æ–™', 'èªªæ˜']],
      ['æ•™ç¨‹', ['æ•™å­¸', 'æŒ‡å—', 'æŒ‡å°']],
      ['API', ['æ¥å£', 'ä»‹é¢', 'interface']],
      ['æ•¸æ“šåº«', ['è³‡æ–™åº«', 'database', 'db']],
      ['é…ç½®', ['è¨­ç½®', 'è¨­å®š', 'config']],
      ['å®‰è£', ['å®‰ç½®', 'éƒ¨ç½²', 'install']],
      ['éŒ¯èª¤', ['å•é¡Œ', 'æ•…éšœ', 'error']],
      ['æ›´æ–°', ['å‡ç´š', 'æ›´æ–°', 'update']],
      ['æœç´¢', ['æœå°‹', 'æŸ¥æ‰¾', 'search']],
      ['é–‹ç™¼', ['é–‹ç™¼', 'ç¨‹å¼è¨­è¨ˆ', 'development']]
    ])
  }

  /**
   * åˆå§‹åŒ–æŠ€è¡“è¡“èªåº«
   */
  private initializeTechnicalTerms(): void {
    this.technicalTerms = new Set([
      'API', 'SDK', 'JSON', 'XML', 'HTTP', 'HTTPS', 'REST', 'GraphQL',
      'SQL', 'NoSQL', 'MongoDB', 'PostgreSQL', 'MySQL',
      'Docker', 'Kubernetes', 'AWS', 'Azure', 'GCP',
      'React', 'Vue', 'Angular', 'Node.js', 'Express',
      'TypeScript', 'JavaScript', 'Python', 'Java', 'C#',
      'OAuth', 'JWT', 'SAML', 'SSL', 'TLS',
      'CI/CD', 'DevOps', 'Microservices', 'Serverless'
    ])
  }

  /**
   * åˆå§‹åŒ–åˆ†é¡é—œéµè©å°ç…§è¡¨
   *
   * ğŸ’¡ Customization Point:
   * æ ¹æ“šæ‚¨çš„æ¥­å‹™é ˜åŸŸè‡ªå®šç¾©åˆ†é¡å’Œé—œéµè©æ˜ å°„
   * é€™è£¡æä¾›äº†ä¸€å€‹é€šç”¨çš„ç¯„ä¾‹ï¼Œæ‚¨æ‡‰è©²æ ¹æ“šå¯¦éš›éœ€æ±‚ä¿®æ”¹
   */
  private initializeCategoryKeywords(): void {
    this.categoryKeywords = new Map([
      // ç”¢å“ç›¸é—œ
      ['ç”¢å“', 'PRODUCT'],
      ['è¦æ ¼', 'PRODUCT'],

      // éŠ·å”®/å¸‚å ´ç›¸é—œ
      ['éŠ·å”®', 'SALES'],
      ['è¡ŒéŠ·', 'SALES'],

      // æŠ€è¡“ç›¸é—œ
      ['æŠ€è¡“', 'TECHNICAL'],
      ['é–‹ç™¼', 'TECHNICAL'],

      // æ³•å¾‹ç›¸é—œ
      ['æ³•å¾‹', 'LEGAL'],
      ['åˆç´„', 'LEGAL'],

      // åŸ¹è¨“ç›¸é—œ
      ['åŸ¹è¨“', 'TRAINING'],
      ['æ•™è‚²', 'TRAINING'],

      // å¸¸è¦‹å•é¡Œ
      ['å¸¸è¦‹å•é¡Œ', 'FAQ'],
      ['å•ç­”', 'FAQ'],

      // æ¡ˆä¾‹ç ”ç©¶
      ['æ¡ˆä¾‹', 'CASE_STUDY'],
      ['ç ”ç©¶', 'CASE_STUDY'],

      // ç™½çš®æ›¸/å ±å‘Š
      ['ç™½çš®æ›¸', 'WHITE_PAPER'],
      ['å ±å‘Š', 'WHITE_PAPER'],

      // ç°¡å ±
      ['ç°¡å ±', 'PRESENTATION'],
      ['æŠ•å½±ç‰‡', 'PRESENTATION'],

      // ç«¶çˆ­åˆ†æ
      ['ç«¶çˆ­', 'COMPETITOR'],
      ['å°æ‰‹', 'COMPETITOR'],

      // æ–°è
      ['æ–°è', 'NEWS'],
      ['æ¶ˆæ¯', 'NEWS']
    ])
  }
}

// å°å‡ºå–®ä¾‹å¯¦ä¾‹
export const queryProcessor = new QueryProcessor()

// ä¾¿åˆ©å‡½æ•¸
export async function parseQuery(query: string): Promise<ParsedQuery> {
  return queryProcessor.parseQuery(query)
}

export async function expandQuery(query: string): Promise<string[]> {
  return queryProcessor.expandQuery(query)
}

export async function detectQueryIntent(query: string): Promise<SearchIntent> {
  return queryProcessor.detectQueryIntent(query)
}

export async function extractQueryKeywords(query: string): Promise<string[]> {
  return queryProcessor.extractQueryKeywords(query)
}
