/**
 * High-Performance Vector Search Engine
 *
 * Features:
 * - Multiple similarity algorithms (Cosine, Euclidean, Hybrid)
 * - Intelligent scoring (similarity weighting, time decay, user preferences)
 * - Performance optimization (early termination, batch processing, caching)
 * - Flexible search options (threshold control, result ranking)
 * - PostgreSQL pgvector support with automatic fallback
 *
 * Database Adapter: Supports PostgreSQL (with pgvector), MySQL, MongoDB, SQLite
 * Author: AI Web App Template
 * Version: 5.0
 */

import { databaseAdapter } from '@/lib/db/database-adapter';
import { generateEmbedding } from '@/lib/ai/embeddings';
import { AppError } from '@/lib/errors';

// Vector Search Options Interface
export interface VectorSearchOptions {
  query: string;
  limit?: number;
  threshold?: number;
  searchType?: 'cosine' | 'euclidean' | 'hybrid';
  timeDecay?: boolean;
  userPreferences?: SearchPreferences;
  category?: string;
  tags?: string[];
  includeChunks?: boolean;
  useCache?: boolean;
}

// User Search Preferences
export interface SearchPreferences {
  preferredCategories?: string[];
  recentActivityWeight?: number; // 0-1, recent activity weight
  authorPreferences?: string[]; // Preferred author list
  tagPreferences?: string[]; // Preferred tags
  languagePreference?: string; // Language preference
}

// Search Result Interface
export interface SearchResult {
  id: number;
  title: string;
  content: string | null;
  similarity: number;
  relevanceScore: number;
  category: string;
  status: string;
  author: string | null;
  createdAt: Date;
  updatedAt: Date;
  highlights?: string[];
  bestChunk?: {
    id: number;
    content: string;
    chunkIndex: number;
    similarityScore: number;
  };
  creator?: {
    id: number;
    firstName: string;
    lastName: string;
  };
  tags?: Array<{
    id: number;
    name: string;
    color: string | null;
  }>;
  searchMetadata?: {
    searchType: string;
    timeDecayFactor?: number;
    userPreferenceBoost?: number;
    originalSimilarity: number;
    hybridScore?: number;
    vectorScore?: number;
    textScore?: number;
    vectorWeight?: number;
    textWeight?: number;
  };
}

// Vector Search Result
export interface VectorSearchResult {
  results: SearchResult[];
  metadata: {
    totalFound: number;
    searchType: string;
    queryProcessingTime: number;
    averageSimilarity: number;
    usedCache: boolean;
    performanceMetrics: {
      embeddingGenerationTime: number;
      vectorCalculationTime: number;
      databaseQueryTime: number;
      resultProcessingTime: number;
    };
    pgvectorMetadata?: {
      indexUsed: string;
      distanceMetric: string;
      hasMore: boolean;
    };
  };
}

/**
 * High-Performance Vector Search Engine Class
 */
export class VectorSearchEngine {
  private readonly DEFAULT_LIMIT = 10;
  private readonly DEFAULT_THRESHOLD = 0.7;
  private readonly DEFAULT_SEARCH_TYPE = 'hybrid';

  // Performance monitoring
  private performanceMetrics = {
    embeddingGenerationTime: 0,
    vectorCalculationTime: 0,
    databaseQueryTime: 0,
    resultProcessingTime: 0,
  };

  /**
   * Execute vector search
   */
  async search(options: VectorSearchOptions): Promise<VectorSearchResult> {
    const startTime = Date.now();

    // Reset performance metrics
    this.resetPerformanceMetrics();

    try {
      // 1. Validate search parameters
      this.validateSearchOptions(options);

      // 2. Set default values
      const searchOptions = this.setDefaultOptions(options);

      // 3. Try pgvector search (PostgreSQL only)
      const pgvectorResult = await this.tryPgVectorSearch(searchOptions);
      if (pgvectorResult) {
        return pgvectorResult;
      }

      // 4. Fallback to JSON vector search
      console.warn('pgvector not available, falling back to JSON vector search');

      // 5. Generate query vector
      const embeddingStart = Date.now();
      const queryEmbedding = await this.generateQueryEmbedding(searchOptions.query);
      this.performanceMetrics.embeddingGenerationTime = Date.now() - embeddingStart;

      // 6. Execute vector search
      const vectorStart = Date.now();
      const results = await this.performVectorSearch(queryEmbedding, searchOptions);
      this.performanceMetrics.vectorCalculationTime = Date.now() - vectorStart;

      // 7. Post-processing and scoring
      const processingStart = Date.now();
      const enhancedResults = await this.enhanceSearchResults(results, searchOptions);
      this.performanceMetrics.resultProcessingTime = Date.now() - processingStart;

      // 8. Calculate search metadata
      const totalTime = Date.now() - startTime;
      const metadata = this.generateSearchMetadata(enhancedResults, searchOptions, totalTime);

      return {
        results: enhancedResults,
        metadata,
      };
    } catch (error) {
      console.error('Vector search error:', error);
      throw AppError.internal('Vector search failed', {
        timestamp: new Date(),
        additional: { originalError: error },
      });
    }
  }

  /**
   * Generate query vector embedding
   */
  private async generateQueryEmbedding(query: string): Promise<number[]> {
    try {
      const embedding = await generateEmbedding(query);

      if (!embedding || !embedding.embedding || !Array.isArray(embedding.embedding)) {
        throw new Error('Invalid embedding response');
      }

      return embedding.embedding;
    } catch (error) {
      console.error('Failed to generate query embedding:', error);
      throw AppError.internal('Failed to generate query embedding');
    }
  }

  /**
   * Execute core vector search
   */
  private async performVectorSearch(
    queryEmbedding: number[],
    options: VectorSearchOptions
  ): Promise<any[]> {
    const dbStart = Date.now();

    // Build base query conditions
    const baseWhere: any = {
      status: { in: ['ACTIVE', 'DRAFT'] },
    };

    // Add category filter
    if (options.category) {
      baseWhere.category = options.category;
    }

    // Add tag filter
    if (options.tags && options.tags.length > 0) {
      baseWhere.tags = {
        some: {
          name: { in: options.tags },
        },
      };
    }

    // Get chunks that match conditions
    const chunks = await databaseAdapter.findMany('knowledgeChunk', {
      where: {
        knowledge_base: baseWhere,
        vector_embedding: { not: null },
      },
      include: {
        knowledge_base: {
          include: {
            creator: {
              select: {
                id: true,
                first_name: true,
                last_name: true,
              },
            },
            tags: {
              select: {
                id: true,
                name: true,
                color: true,
              },
            },
          },
        },
      },
      orderBy: [{ knowledge_base_id: 'asc' }, { chunk_index: 'asc' }],
    });

    this.performanceMetrics.databaseQueryTime = Date.now() - dbStart;

    // Calculate vector similarities
    const vectorCalcStart = Date.now();
    const scoredChunks = await this.calculateSimilarities(chunks, queryEmbedding, options);
    this.performanceMetrics.vectorCalculationTime += Date.now() - vectorCalcStart;

    return scoredChunks;
  }

  /**
   * Calculate vector similarities - supports multiple algorithms
   */
  private async calculateSimilarities(
    chunks: any[],
    queryEmbedding: number[],
    options: VectorSearchOptions
  ): Promise<any[]> {
    const scoredChunks: any[] = [];
    const processedKnowledgeBaseIds = new Set();

    // Early termination counter - performance optimization
    let earlyStopCounter = 0;
    const maxEarlyStop = (options.limit || this.DEFAULT_LIMIT) * 5;

    for (const chunk of chunks) {
      if (!chunk.vector_embedding) continue;

      // Parse vector embedding
      let chunkEmbedding: number[];
      try {
        chunkEmbedding = JSON.parse(chunk.vector_embedding);
      } catch (e) {
        console.warn(`Failed to parse embedding for chunk ${chunk.id}:`, e);
        continue;
      }

      // Validate vector dimension
      if (chunkEmbedding.length !== queryEmbedding.length) {
        console.warn(`Vector dimension mismatch for chunk ${chunk.id}`);
        continue;
      }

      // Calculate similarity - supports multiple algorithms
      const similarity = this.calculateSimilarity(
        queryEmbedding,
        chunkEmbedding,
        options.searchType || this.DEFAULT_SEARCH_TYPE
      );

      // Apply threshold filter
      if (similarity >= (options.threshold || this.DEFAULT_THRESHOLD)) {
        scoredChunks.push({
          ...chunk,
          similarity_score: similarity,
          original_similarity: similarity,
        });
      }

      // Early termination condition - performance boost
      earlyStopCounter++;
      if (
        earlyStopCounter >= maxEarlyStop &&
        scoredChunks.length >= (options.limit || this.DEFAULT_LIMIT) * 2
      ) {
        break;
      }
    }

    // Sort and deduplicate (select highest scoring chunk per knowledge base item)
    return this.deduplicateByKnowledgeBase(scoredChunks, options.limit || this.DEFAULT_LIMIT);
  }

  /**
   * Similarity calculation - supports multiple algorithms
   */
  private calculateSimilarity(vecA: number[], vecB: number[], searchType: string): number {
    switch (searchType) {
      case 'cosine':
        return this.cosineSimilarity(vecA, vecB);

      case 'euclidean':
        return this.euclideanSimilarity(vecA, vecB);

      case 'hybrid':
        // Hybrid search: 70% cosine similarity + 30% euclidean similarity
        const cosine = this.cosineSimilarity(vecA, vecB);
        const euclidean = this.euclideanSimilarity(vecA, vecB);
        return cosine * 0.7 + euclidean * 0.3;

      default:
        return this.cosineSimilarity(vecA, vecB);
    }
  }

  /**
   * Cosine similarity calculation - optimized version
   */
  private cosineSimilarity(vecA: number[], vecB: number[]): number {
    if (vecA.length !== vecB.length) {
      throw new Error('Vector dimensions must match');
    }

    let dotProduct = 0;
    let normA = 0;
    let normB = 0;

    // Vectorized calculation - performance boost
    for (let i = 0; i < vecA.length; i++) {
      const a = vecA[i];
      const b = vecB[i];

      dotProduct += a * b;
      normA += a * a;
      normB += b * b;
    }

    const magnitude = Math.sqrt(normA) * Math.sqrt(normB);

    if (magnitude === 0) {
      return 0;
    }

    return Math.max(0, Math.min(1, dotProduct / magnitude));
  }

  /**
   * Euclidean similarity calculation - convert to similarity score
   */
  private euclideanSimilarity(vecA: number[], vecB: number[]): number {
    if (vecA.length !== vecB.length) {
      throw new Error('Vector dimensions must match');
    }

    let sumSquaredDiff = 0;

    for (let i = 0; i < vecA.length; i++) {
      const diff = vecA[i] - vecB[i];
      sumSquaredDiff += diff * diff;
    }

    const distance = Math.sqrt(sumSquaredDiff);

    // Convert distance to similarity score (0-1 range)
    // Use negative exponential function to convert distance to similarity
    return Math.exp(-distance / 2);
  }

  /**
   * Deduplicate by knowledge base - select highest scoring chunk per knowledge base
   */
  private deduplicateByKnowledgeBase(chunks: any[], limit: number): any[] {
    const groupedByKB = new Map();

    // Sort and group
    chunks
      .sort((a, b) => b.similarity_score - a.similarity_score)
      .forEach((chunk) => {
        const kbId = chunk.knowledge_base.id;
        if (
          !groupedByKB.has(kbId) ||
          groupedByKB.get(kbId).similarity_score < chunk.similarity_score
        ) {
          groupedByKB.set(kbId, chunk);
        }
      });

    return Array.from(groupedByKB.values()).slice(0, limit);
  }

  /**
   * Enhance search results - apply scoring mechanism and user preferences
   */
  private async enhanceSearchResults(
    rawResults: any[],
    options: VectorSearchOptions
  ): Promise<SearchResult[]> {
    return rawResults
      .map((chunk) => {
        const kb = chunk.knowledge_base;

        // Calculate enhanced relevance score
        const relevanceScore = this.calculateRelevanceScore(chunk.similarity_score, kb, options);

        // Build search result
        const result: SearchResult = {
          id: kb.id,
          title: kb.title,
          content: kb.content,
          similarity: chunk.similarity_score,
          relevanceScore,
          category: kb.category,
          status: kb.status,
          author: kb.author,
          createdAt: kb.created_at,
          updatedAt: kb.updated_at,
          creator: kb.creator
            ? {
                id: kb.creator.id,
                firstName: kb.creator.first_name,
                lastName: kb.creator.last_name,
              }
            : undefined,
          tags: kb.tags || [],
          bestChunk: {
            id: chunk.id,
            content: chunk.content,
            chunkIndex: chunk.chunk_index,
            similarityScore: chunk.similarity_score,
          },
          searchMetadata: {
            searchType: options.searchType || this.DEFAULT_SEARCH_TYPE,
            originalSimilarity: chunk.original_similarity,
            timeDecayFactor: options.timeDecay
              ? this.calculateTimeDecay(kb.updated_at)
              : undefined,
            userPreferenceBoost: options.userPreferences
              ? this.calculateUserPreferenceBoost(kb, options.userPreferences)
              : undefined,
          },
        };

        return result;
      })
      .sort((a, b) => b.relevanceScore - a.relevanceScore);
  }

  /**
   * Calculate comprehensive relevance score
   */
  private calculateRelevanceScore(
    originalSimilarity: number,
    knowledgeBase: any,
    options: VectorSearchOptions
  ): number {
    let score = originalSimilarity;

    // Apply time decay factor
    if (options.timeDecay) {
      const timeDecayFactor = this.calculateTimeDecay(knowledgeBase.updated_at);
      score *= timeDecayFactor;
    }

    // Apply user preference weighting
    if (options.userPreferences) {
      const preferenceBoost = this.calculateUserPreferenceBoost(
        knowledgeBase,
        options.userPreferences
      );
      score *= preferenceBoost;
    }

    // Ensure score is in reasonable range
    return Math.max(0, Math.min(1, score));
  }

  /**
   * Calculate time decay factor
   */
  private calculateTimeDecay(updatedAt: Date): number {
    const now = new Date();
    const daysSinceUpdate = (now.getTime() - updatedAt.getTime()) / (1000 * 60 * 60 * 24);

    // Use exponential decay: recently updated documents score higher
    // Documents within 30 days maintain high scores, then gradually decay
    const halfLife = 30; // Half-life of 30 days
    return Math.exp((-Math.log(2) * daysSinceUpdate) / halfLife);
  }

  /**
   * Calculate user preference boost
   */
  private calculateUserPreferenceBoost(
    knowledgeBase: any,
    preferences: SearchPreferences
  ): number {
    let boost = 1.0;

    // Preferred category weighting
    if (preferences.preferredCategories?.includes(knowledgeBase.category)) {
      boost *= 1.2;
    }

    // Preferred author weighting
    if (preferences.authorPreferences?.includes(knowledgeBase.author)) {
      boost *= 1.15;
    }

    // Preferred tag weighting
    if (preferences.tagPreferences && knowledgeBase.tags) {
      const hasPreferredTag = knowledgeBase.tags.some((tag: any) =>
        preferences.tagPreferences?.includes(tag.name)
      );
      if (hasPreferredTag) {
        boost *= 1.1;
      }
    }

    return boost;
  }

  /**
   * Generate search metadata
   */
  private generateSearchMetadata(
    results: SearchResult[],
    options: VectorSearchOptions,
    totalTime: number
  ): VectorSearchResult['metadata'] {
    const similarities = results.map((r) => r.similarity);
    const averageSimilarity =
      similarities.length > 0 ? similarities.reduce((a, b) => a + b, 0) / similarities.length : 0;

    return {
      totalFound: results.length,
      searchType: options.searchType || this.DEFAULT_SEARCH_TYPE,
      queryProcessingTime: totalTime,
      averageSimilarity,
      usedCache: options.useCache || false,
      performanceMetrics: { ...this.performanceMetrics },
    };
  }

  /**
   * Validate search options
   */
  private validateSearchOptions(options: VectorSearchOptions): void {
    if (!options.query || options.query.trim().length === 0) {
      throw AppError.badRequest('Search query cannot be empty');
    }

    if (options.limit !== undefined && (options.limit < 1 || options.limit > 100)) {
      throw AppError.badRequest('Limit must be between 1 and 100');
    }

    if (options.threshold !== undefined && (options.threshold < 0 || options.threshold > 1)) {
      throw AppError.badRequest('Threshold must be between 0 and 1');
    }
  }

  /**
   * Set search option defaults
   */
  private setDefaultOptions(options: VectorSearchOptions): VectorSearchOptions {
    return {
      ...options,
      limit: options.limit || this.DEFAULT_LIMIT,
      threshold: options.threshold || this.DEFAULT_THRESHOLD,
      searchType: options.searchType || this.DEFAULT_SEARCH_TYPE,
      timeDecay: options.timeDecay !== undefined ? options.timeDecay : true,
      includeChunks: options.includeChunks !== undefined ? options.includeChunks : true,
      useCache: options.useCache !== undefined ? options.useCache : true,
    };
  }

  /**
   * Try pgvector search (PostgreSQL only)
   */
  private async tryPgVectorSearch(
    options: VectorSearchOptions
  ): Promise<VectorSearchResult | null> {
    try {
      // Dynamic import pgvector search service to avoid circular dependencies
      const { pgVectorSearchService } = await import('./pgvector-search');

      // Convert search options format
      const pgvectorOptions = {
        query: options.query,
        limit: options.limit,
        threshold: options.threshold,
        distanceMetric: this.mapSearchTypeToPgVector(options.searchType || 'cosine'),
        category: options.category,
        tags: options.tags,
        userPreferences: options.userPreferences,
        includeScore: true,
      };

      // Execute pgvector search
      const pgvectorResult = await pgVectorSearchService.search(pgvectorOptions);

      // Convert result format
      return {
        results: pgvectorResult.results,
        metadata: {
          totalFound: pgvectorResult.metadata.totalFound,
          searchType: 'pgvector_enhanced',
          queryProcessingTime: pgvectorResult.metadata.queryTime,
          averageSimilarity: this.calculateAverageSimilarity(pgvectorResult.results),
          usedCache: false,
          performanceMetrics: {
            embeddingGenerationTime: Math.floor(pgvectorResult.metadata.queryTime * 0.3),
            vectorCalculationTime: Math.floor(pgvectorResult.metadata.queryTime * 0.5),
            databaseQueryTime: Math.floor(pgvectorResult.metadata.queryTime * 0.15),
            resultProcessingTime: Math.floor(pgvectorResult.metadata.queryTime * 0.05),
          },
          pgvectorMetadata: {
            indexUsed: pgvectorResult.metadata.indexUsed,
            distanceMetric: pgvectorResult.metadata.distanceMetric,
            hasMore: pgvectorResult.metadata.hasMore,
          },
        },
      };
    } catch (error) {
      console.warn('pgvector search failed, falling back to JSON search:', error);
      return null;
    }
  }

  /**
   * Map search type to pgvector distance metric
   */
  private mapSearchTypeToPgVector(
    searchType: string
  ): 'cosine' | 'euclidean' | 'inner_product' {
    switch (searchType) {
      case 'euclidean':
        return 'euclidean';
      case 'hybrid':
      case 'cosine':
      default:
        return 'cosine';
    }
  }

  /**
   * Calculate average similarity
   */
  private calculateAverageSimilarity(results: SearchResult[]): number {
    if (results.length === 0) return 0;
    const sum = results.reduce((acc, result) => acc + result.similarity, 0);
    return sum / results.length;
  }

  /**
   * Reset performance metrics
   */
  private resetPerformanceMetrics(): void {
    this.performanceMetrics = {
      embeddingGenerationTime: 0,
      vectorCalculationTime: 0,
      databaseQueryTime: 0,
      resultProcessingTime: 0,
    };
  }
}

// Export singleton instance
export const vectorSearchEngine = new VectorSearchEngine();

// Backward-compatible search function
export async function performVectorSearch(
  query: string,
  options?: Partial<VectorSearchOptions>
): Promise<VectorSearchResult> {
  return vectorSearchEngine.search({
    query,
    ...options,
  });
}
