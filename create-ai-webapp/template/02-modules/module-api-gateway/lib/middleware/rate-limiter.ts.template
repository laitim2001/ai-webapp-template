/**
 * APIé€Ÿç‡é™åˆ¶ä¸­é–“ä»¶
 *
 * åŠŸèƒ½ï¼š
 * - åŸºæ–¼ç”¨æˆ¶IDå’ŒIPåœ°å€çš„é€Ÿç‡é™åˆ¶
 * - æ”¯æ´ä¸åŒAPIç«¯é»çš„ä¸åŒé™åˆ¶ç­–ç•¥
 * - Redisç·©å­˜æ”¯æ´ï¼ˆå¯é¸ï¼‰
 * - å…§å­˜ç·©å­˜å›é€€æ©Ÿåˆ¶
 * - é€Ÿç‡é™åˆ¶ç‹€æ…‹è¿½è¹¤å’Œæ—¥èªŒ
 *
 * ğŸ’¡ ç”Ÿç”¢ç’°å¢ƒå»ºè­°ï¼š
 * - ä½¿ç”¨ Redis æ›¿ä»£å…§å­˜å­˜å„²ä»¥æ”¯æ´åˆ†ä½ˆå¼éƒ¨ç½²
 * - æ ¹æ“šå¯¦éš›éœ€æ±‚èª¿æ•´é è¨­é…ç½®
 * - ç›£æ§é€Ÿç‡é™åˆ¶çµ±è¨ˆä»¥å„ªåŒ–é™åˆ¶ç­–ç•¥
 */

import { NextRequest, NextResponse } from 'next/server';

// é€Ÿç‡é™åˆ¶é…ç½®ä»‹é¢
export interface RateLimitConfig {
  windowMs: number;          // æ™‚é–“çª—å£ï¼ˆæ¯«ç§’ï¼‰
  maxRequests: number;       // æœ€å¤§è«‹æ±‚æ•¸
  keyGenerator?: (req: NextRequest) => string; // è‡ªå®šç¾©keyç”Ÿæˆå™¨
  skipSuccessfulRequests?: boolean; // æ˜¯å¦è·³éæˆåŠŸçš„è«‹æ±‚
  skipFailedRequests?: boolean;     // æ˜¯å¦è·³éå¤±æ•—çš„è«‹æ±‚
  message?: string;          // è‡ªå®šç¾©éŒ¯èª¤æ¶ˆæ¯
  headers?: boolean;         // æ˜¯å¦æ·»åŠ é€Ÿç‡é™åˆ¶é ­éƒ¨
}

// é€Ÿç‡é™åˆ¶è¨˜éŒ„ä»‹é¢
interface RateLimitRecord {
  count: number;
  resetTime: number;
  firstRequest: number;
}

// å…§å­˜å­˜å„²ï¼ˆç”Ÿç”¢ç’°å¢ƒå»ºè­°ä½¿ç”¨Redisï¼‰
class MemoryStore {
  private store = new Map<string, RateLimitRecord>();
  private cleanupInterval: NodeJS.Timeout;

  constructor() {
    // æ¯5åˆ†é˜æ¸…ç†ä¸€æ¬¡éæœŸè¨˜éŒ„
    this.cleanupInterval = setInterval(() => {
      this.cleanup();
    }, 5 * 60 * 1000);
  }

  async get(key: string): Promise<RateLimitRecord | null> {
    const record = this.store.get(key);
    if (!record) return null;

    // æª¢æŸ¥æ˜¯å¦éæœŸ
    if (Date.now() > record.resetTime) {
      this.store.delete(key);
      return null;
    }

    return record;
  }

  async set(key: string, record: RateLimitRecord): Promise<void> {
    this.store.set(key, record);
  }

  async increment(key: string, windowMs: number): Promise<RateLimitRecord> {
    const now = Date.now();
    const existing = await this.get(key);

    if (existing) {
      existing.count++;
      await this.set(key, existing);
      return existing;
    } else {
      const newRecord: RateLimitRecord = {
        count: 1,
        resetTime: now + windowMs,
        firstRequest: now
      };
      await this.set(key, newRecord);
      return newRecord;
    }
  }

  private cleanup(): void {
    const now = Date.now();
    for (const [key, record] of this.store.entries()) {
      if (now > record.resetTime) {
        this.store.delete(key);
      }
    }
  }

  destroy(): void {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
    }
    this.store.clear();
  }
}

// å…¨å±€å­˜å„²å¯¦ä¾‹
const store = new MemoryStore();

/**
 * é å®šç¾©çš„é€Ÿç‡é™åˆ¶é…ç½®
 *
 * ğŸ’¡ Customization Point:
 * æ ¹æ“šæ‚¨çš„æ¥­å‹™éœ€æ±‚è‡ªå®šç¾©é€™äº›é è¨­å€¼
 */
export const RateLimitPresets = {
  // ä¸€èˆ¬API - ä¸­ç­‰é™åˆ¶
  GENERAL_API: {
    windowMs: 60 * 1000,     // 1åˆ†é˜
    maxRequests: 60,         // æœ€å¤š60æ¬¡è«‹æ±‚
    message: 'APIèª¿ç”¨éæ–¼é »ç¹ï¼Œè«‹ç¨å¾Œå†è©¦'
  },

  // æª”æ¡ˆä¸Šå‚³ - å¯¬é¬†é™åˆ¶
  FILE_UPLOAD: {
    windowMs: 60 * 1000,     // 1åˆ†é˜
    maxRequests: 5,          // æœ€å¤š5æ¬¡ä¸Šå‚³
    message: 'æª”æ¡ˆä¸Šå‚³éæ–¼é »ç¹ï¼Œè«‹ç¨å¾Œå†è©¦'
  },

  // ç™»å…¥å˜—è©¦ - åš´æ ¼é™åˆ¶
  AUTH_ATTEMPT: {
    windowMs: 15 * 60 * 1000, // 15åˆ†é˜
    maxRequests: 5,           // æœ€å¤š5æ¬¡å˜—è©¦
    message: 'ç™»å…¥å˜—è©¦æ¬¡æ•¸éå¤šï¼Œè«‹15åˆ†é˜å¾Œå†è©¦'
  },

  // æœç´¢è«‹æ±‚ - ä¸­ç­‰é™åˆ¶
  SEARCH_API: {
    windowMs: 60 * 1000,     // 1åˆ†é˜
    maxRequests: 30,         // æœ€å¤š30æ¬¡æœç´¢
    message: 'æœç´¢è«‹æ±‚éæ–¼é »ç¹ï¼Œè«‹ç¨å¾Œå†è©¦'
  },

  // åš´æ ¼API - ç”¨æ–¼æ•æ„Ÿæ“ä½œ
  STRICT_API: {
    windowMs: 60 * 1000,     // 1åˆ†é˜
    maxRequests: 10,         // æœ€å¤š10æ¬¡è«‹æ±‚
    message: 'APIèª¿ç”¨éæ–¼é »ç¹ï¼Œè«‹ç¨å¾Œå†è©¦'
  }
} as const;

/**
 * é»˜èªkeyç”Ÿæˆå™¨
 */
function defaultKeyGenerator(req: NextRequest): string {
  // å„ªå…ˆä½¿ç”¨ç”¨æˆ¶IDï¼Œå›é€€åˆ°IPåœ°å€
  const userId = req.headers.get('x-user-id') ||
                 req.headers.get('authorization')?.split(' ')[1]; // å¾JWTä¸­æå–
  const ip = req.headers.get('x-forwarded-for') ||
             req.headers.get('x-real-ip') ||
             req.ip ||
             'unknown';

  return userId ? `user:${userId}` : `ip:${ip}`;
}

/**
 * å‰µå»ºé€Ÿç‡é™åˆ¶ä¸­é–“ä»¶
 */
export function createRateLimit(config: RateLimitConfig) {
  const {
    windowMs,
    maxRequests,
    keyGenerator = defaultKeyGenerator,
    skipSuccessfulRequests = false,
    skipFailedRequests = false,
    message = 'è«‹æ±‚éæ–¼é »ç¹ï¼Œè«‹ç¨å¾Œå†è©¦',
    headers = true
  } = config;

  return async function rateLimitMiddleware(
    req: NextRequest,
    next?: () => Promise<NextResponse>
  ): Promise<NextResponse | null> {
    try {
      const key = keyGenerator(req);
      const record = await store.increment(key, windowMs);

      const isLimitExceeded = record.count > maxRequests;
      const timeUntilReset = Math.ceil((record.resetTime - Date.now()) / 1000);

      // å‰µå»ºéŸ¿æ‡‰é ­
      const responseHeaders: Record<string, string> = {};

      if (headers) {
        responseHeaders['X-RateLimit-Limit'] = maxRequests.toString();
        responseHeaders['X-RateLimit-Remaining'] = Math.max(0, maxRequests - record.count).toString();
        responseHeaders['X-RateLimit-Reset'] = Math.ceil(record.resetTime / 1000).toString();
        responseHeaders['X-RateLimit-Window'] = windowMs.toString();
      }

      // å¦‚æœè¶…å‡ºé™åˆ¶
      if (isLimitExceeded) {
        responseHeaders['Retry-After'] = timeUntilReset.toString();

        // è¨˜éŒ„é€Ÿç‡é™åˆ¶äº‹ä»¶
        console.warn(`Rate limit exceeded for key: ${key}, count: ${record.count}, limit: ${maxRequests}`);

        return NextResponse.json(
          {
            success: false,
            error: 'RATE_LIMIT_EXCEEDED',
            message,
            retryAfter: timeUntilReset
          },
          {
            status: 429,
            headers: responseHeaders
          }
        );
      }

      // å¦‚æœæœ‰nextå‡½æ•¸ï¼Œèª¿ç”¨å®ƒä¸¦æ·»åŠ é ­éƒ¨
      if (next) {
        const response = await next();

        // æª¢æŸ¥æ˜¯å¦æ‡‰è©²è·³éè¨ˆæ•¸
        const shouldSkip = (
          (skipSuccessfulRequests && response.status < 400) ||
          (skipFailedRequests && response.status >= 400)
        );

        if (shouldSkip) {
          // æ¸›å°‘è¨ˆæ•¸ï¼ˆå› ç‚ºä¹‹å‰å·²ç¶“å¢åŠ äº†ï¼‰
          record.count = Math.max(0, record.count - 1);
          await store.set(key, record);
        }

        // æ·»åŠ é€Ÿç‡é™åˆ¶é ­éƒ¨
        if (headers) {
          Object.entries(responseHeaders).forEach(([name, value]) => {
            response.headers.set(name, value);
          });
        }

        return response;
      }

      return null;
    } catch (error) {
      console.error('Rate limiter error:', error);
      // åœ¨éŒ¯èª¤æƒ…æ³ä¸‹ï¼Œå…è¨±è«‹æ±‚é€šé
      return next ? await next() : null;
    }
  };
}

/**
 * é€Ÿç‡é™åˆ¶ç‹€æ…‹æª¢æŸ¥
 */
export async function checkRateLimit(
  key: string,
  config: RateLimitConfig
): Promise<{
  allowed: boolean;
  count: number;
  remaining: number;
  resetTime: number;
  retryAfter?: number;
}> {
  try {
    const record = await store.get(key);

    if (!record) {
      return {
        allowed: true,
        count: 0,
        remaining: config.maxRequests,
        resetTime: Date.now() + config.windowMs
      };
    }

    const allowed = record.count < config.maxRequests;
    const remaining = Math.max(0, config.maxRequests - record.count);
    const retryAfter = allowed ? undefined : Math.ceil((record.resetTime - Date.now()) / 1000);

    return {
      allowed,
      count: record.count,
      remaining,
      resetTime: record.resetTime,
      retryAfter
    };
  } catch (error) {
    console.error('Rate limit check error:', error);
    // éŒ¯èª¤æƒ…æ³ä¸‹å…è¨±è«‹æ±‚
    return {
      allowed: true,
      count: 0,
      remaining: config.maxRequests,
      resetTime: Date.now() + config.windowMs
    };
  }
}

/**
 * æ¸…é™¤ç”¨æˆ¶çš„é€Ÿç‡é™åˆ¶è¨˜éŒ„
 */
export async function clearRateLimit(key: string): Promise<void> {
  try {
    await store.set(key, { count: 0, resetTime: 0, firstRequest: 0 });
  } catch (error) {
    console.error('Clear rate limit error:', error);
  }
}

/**
 * ç²å–é€Ÿç‡é™åˆ¶çµ±è¨ˆ
 */
export async function getRateLimitStats(): Promise<{
  totalKeys: number;
  activeKeys: number;
  topKeys: Array<{ key: string; count: number; resetTime: number }>;
}> {
  try {
    const now = Date.now();
    let totalKeys = 0;
    let activeKeys = 0;
    const keyStats: Array<{ key: string; count: number; resetTime: number }> = [];

    // æ³¨æ„ï¼šé€™è£¡è¨ªå•ç§æœ‰å±¬æ€§åƒ…ç”¨æ–¼çµ±è¨ˆï¼Œç”Ÿç”¢ç’°å¢ƒå»ºè­°æ·»åŠ å…¬å…±æ–¹æ³•
    for (const [key, record] of (store as any).store.entries()) {
      totalKeys++;
      if (record.resetTime > now) {
        activeKeys++;
        keyStats.push({
          key: key.replace(/^(user:|ip:)/, ''), // éš±è—å‰ç¶´ä»¥ä¿è­·éš±ç§
          count: record.count,
          resetTime: record.resetTime
        });
      }
    }

    // æŒ‰è¨ˆæ•¸æ’åºï¼Œå–å‰10å€‹
    const topKeys = keyStats
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);

    return {
      totalKeys,
      activeKeys,
      topKeys
    };
  } catch (error) {
    console.error('Get rate limit stats error:', error);
    return {
      totalKeys: 0,
      activeKeys: 0,
      topKeys: []
    };
  }
}

/**
 * é€Ÿç‡é™åˆ¶è£é£¾å™¨ï¼ˆç”¨æ–¼APIè·¯ç”±ï¼‰
 */
export function withRateLimit(config: RateLimitConfig) {
  return function decorator(handler: Function) {
    return async function rateLimitedHandler(req: NextRequest, ...args: any[]) {
      const rateLimit = createRateLimit(config);

      const limitResult = await rateLimit(req, async () => {
        return await handler(req, ...args);
      });

      return limitResult || await handler(req, ...args);
    };
  };
}

// å°å‡ºå­˜å„²å¯¦ä¾‹ä»¥ä¾›æ¸¬è©¦ä½¿ç”¨
export { store as rateLimitStore };
