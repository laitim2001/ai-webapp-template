/**
 * Unified Error Handling System
 *
 * Production-ready error handling framework for Next.js applications.
 * Provides structured error management, automatic classification, and logging.
 *
 * Features:
 * - Layered error handling (operational vs programmatic errors)
 * - Automatic error classification (Prisma, JWT, Network, etc.)
 * - Safe client responses (automatic filtering of sensitive info)
 * - Structured logging with environment-specific strategies
 * - Error metrics collection for monitoring
 * - Request ID tracking for debugging
 *
 * @module lib/errors
 * @created {{CURRENT_DATE}}
 */

/**
 * Error Type Enumeration
 *
 * Defines all possible error types in the application,
 * grouped by functional domain for easier handling and analysis.
 */
export enum ErrorType {
  // Authentication Errors
  UNAUTHORIZED = 'UNAUTHORIZED',
  FORBIDDEN = 'FORBIDDEN',
  TOKEN_EXPIRED = 'TOKEN_EXPIRED',
  INVALID_CREDENTIALS = 'INVALID_CREDENTIALS',

  // Validation Errors
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  INVALID_INPUT = 'INVALID_INPUT',
  REQUIRED_FIELD_MISSING = 'REQUIRED_FIELD_MISSING',

  // Resource Errors
  NOT_FOUND = 'NOT_FOUND',
  RESOURCE_CONFLICT = 'RESOURCE_CONFLICT',
  RESOURCE_LOCKED = 'RESOURCE_LOCKED',

  // Service Errors
  INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',
  SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE',
  DATABASE_ERROR = 'DATABASE_ERROR',
  EXTERNAL_API_ERROR = 'EXTERNAL_API_ERROR',

  // AI Service Errors
  AI_SERVICE_ERROR = 'AI_SERVICE_ERROR',
  EMBEDDING_GENERATION_FAILED = 'EMBEDDING_GENERATION_FAILED',
  CHAT_COMPLETION_FAILED = 'CHAT_COMPLETION_FAILED',
  RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED',

  // Network Errors
  NETWORK_ERROR = 'NETWORK_ERROR',
  TIMEOUT_ERROR = 'TIMEOUT_ERROR',
  CONNECTION_ERROR = 'CONNECTION_ERROR',

  // Business Logic Errors
  BUSINESS_LOGIC_ERROR = 'BUSINESS_LOGIC_ERROR',
  INSUFFICIENT_PERMISSIONS = 'INSUFFICIENT_PERMISSIONS',
  QUOTA_EXCEEDED = 'QUOTA_EXCEEDED',

  // File Processing Errors
  FILE_UPLOAD_ERROR = 'FILE_UPLOAD_ERROR',
  FILE_TOO_LARGE = 'FILE_TOO_LARGE',
  UNSUPPORTED_FILE_TYPE = 'UNSUPPORTED_FILE_TYPE',
  FILE_PROCESSING_ERROR = 'FILE_PROCESSING_ERROR',

  // Unknown Errors
  UNKNOWN_ERROR = 'UNKNOWN_ERROR',
}

/**
 * Error Severity Levels
 *
 * Classification of error severity affecting logging strategy,
 * monitoring alerts, and error handling priority.
 *
 * Levels:
 * - LOW: General errors, doesn't affect core functionality
 * - MEDIUM: Moderate errors, may affect user experience
 * - HIGH: Serious errors, affects system functionality
 * - CRITICAL: Critical errors, may cause system failure
 */
export enum ErrorSeverity {
  LOW = 'LOW',
  MEDIUM = 'MEDIUM',
  HIGH = 'HIGH',
  CRITICAL = 'CRITICAL',
}

/**
 * Error Context Interface
 *
 * Contains environmental information when error occurs,
 * used for error tracking, debugging, and analysis.
 */
export interface ErrorContext {
  userId?: string
  requestId?: string
  path?: string
  method?: string
  userAgent?: string
  timestamp: Date
  additional?: Record<string, any>
}

/**
 * Application Error Class
 *
 * Core error class extending native Error with structured handling.
 * All business logic errors should use this class or its derivatives.
 *
 * Features:
 * - Error type and severity classification
 * - Error context tracking
 * - Auto-generate safe client responses
 * - Original error chain tracking
 * - Distinguish operational vs programmatic errors
 *
 * @example
 * ```typescript
 * // Basic usage
 * throw new AppError('Resource not found', ErrorType.NOT_FOUND, 404)
 *
 * // Full usage
 * throw new AppError(
 *   'Database connection failed',
 *   ErrorType.DATABASE_ERROR,
 *   500,
 *   ErrorSeverity.HIGH,
 *   true,
 *   context,
 *   originalError
 * )
 * ```
 */
export class AppError extends Error {
  public readonly type: ErrorType
  public readonly severity: ErrorSeverity
  public readonly statusCode: number
  public readonly isOperational: boolean
  public readonly context?: ErrorContext
  public readonly originalError?: Error

  constructor(
    message: string,
    type: ErrorType = ErrorType.UNKNOWN_ERROR,
    statusCode: number = 500,
    severity: ErrorSeverity = ErrorSeverity.MEDIUM,
    isOperational: boolean = true,
    context?: ErrorContext,
    originalError?: Error
  ) {
    super(message)

    this.name = 'AppError'
    this.type = type
    this.severity = severity
    this.statusCode = statusCode
    this.isOperational = isOperational
    this.context = context
    this.originalError = originalError

    // Ensure correct stack trace
    Error.captureStackTrace(this, AppError)
  }

  /**
   * Static convenience methods for common errors
   */

  static unauthorized(message = 'Unauthorized', context?: ErrorContext): AppError {
    return new AppError(message, ErrorType.UNAUTHORIZED, 401, ErrorSeverity.MEDIUM, true, context)
  }

  static forbidden(message = 'Forbidden', context?: ErrorContext): AppError {
    return new AppError(message, ErrorType.FORBIDDEN, 403, ErrorSeverity.MEDIUM, true, context)
  }

  static notFound(message = 'Resource not found', context?: ErrorContext): AppError {
    return new AppError(message, ErrorType.NOT_FOUND, 404, ErrorSeverity.LOW, true, context)
  }

  static validation(message: string, context?: ErrorContext): AppError {
    return new AppError(message, ErrorType.VALIDATION_ERROR, 400, ErrorSeverity.LOW, true, context)
  }

  static badRequest(message = 'Bad request', context?: ErrorContext): AppError {
    return new AppError(message, ErrorType.INVALID_INPUT, 400, ErrorSeverity.LOW, true, context)
  }

  static internal(message = 'Internal server error', context?: ErrorContext, originalError?: Error): AppError {
    return new AppError(message, ErrorType.INTERNAL_SERVER_ERROR, 500, ErrorSeverity.HIGH, true, context, originalError)
  }

  static aiService(message: string, context?: ErrorContext, originalError?: Error): AppError {
    return new AppError(message, ErrorType.AI_SERVICE_ERROR, 500, ErrorSeverity.HIGH, true, context, originalError)
  }

  static rateLimited(message = 'Rate limit exceeded', context?: ErrorContext): AppError {
    return new AppError(message, ErrorType.RATE_LIMIT_EXCEEDED, 429, ErrorSeverity.MEDIUM, true, context)
  }

  /**
   * Convert to safe client response
   *
   * Converts error to format safe for client transmission.
   * Automatically filters sensitive information.
   */
  toClientResponse(): {
    error: {
      type: string
      message: string
      statusCode: number
      timestamp: string
      requestId?: string
    }
  } {
    return {
      error: {
        type: this.type,
        message: this.isOperational ? this.message : 'An unexpected error occurred',
        statusCode: this.statusCode,
        timestamp: new Date().toISOString(),
        requestId: this.context?.requestId,
      }
    }
  }

  /**
   * Convert to structured log format
   *
   * Converts error to format suitable for logging systems.
   * Includes complete error information and context.
   */
  toLogFormat(): {
    level: string
    message: string
    type: string
    severity: string
    statusCode: number
    stack?: string
    context?: ErrorContext
    originalError?: {
      name: string
      message: string
      stack?: string
    }
  } {
    return {
      level: this.severity === ErrorSeverity.CRITICAL ? 'error' :
             this.severity === ErrorSeverity.HIGH ? 'error' :
             this.severity === ErrorSeverity.MEDIUM ? 'warn' : 'info',
      message: this.message,
      type: this.type,
      severity: this.severity,
      statusCode: this.statusCode,
      stack: this.stack,
      context: this.context,
      originalError: this.originalError ? {
        name: this.originalError.name,
        message: this.originalError.message,
        stack: this.originalError.stack,
      } : undefined,
    }
  }
}

/**
 * Error Classifier
 *
 * Automatically identifies and converts various raw errors to unified AppError format.
 * Supports error pattern recognition for multiple third-party libraries and services.
 *
 * Supported error types:
 * - Prisma database errors (P2002, P2025, etc.)
 * - JWT authentication errors
 * - Network connection errors
 * - Azure OpenAI service errors
 * - File processing errors
 * - Input validation errors (Zod, ValidationError)
 *
 * @example
 * ```typescript
 * try {
 *   await riskyOperation()
 * } catch (error) {
 *   const appError = ErrorClassifier.classify(error, context)
 *   await ErrorLogger.log(appError)
 *   throw appError
 * }
 * ```
 */
export class ErrorClassifier {
  static classify(error: any, context?: ErrorContext): AppError {
    if (error instanceof AppError) {
      return error
    }

    // Prisma Errors
    if (error?.code === 'P2002') {
      return new AppError(
        'Resource already exists',
        ErrorType.RESOURCE_CONFLICT,
        409,
        ErrorSeverity.LOW,
        true,
        context,
        error
      )
    }

    if (error?.code === 'P2025') {
      return new AppError(
        'Resource not found',
        ErrorType.NOT_FOUND,
        404,
        ErrorSeverity.LOW,
        true,
        context,
        error
      )
    }

    // JWT Errors
    if (error?.name === 'JsonWebTokenError') {
      return new AppError(
        'Invalid token',
        ErrorType.UNAUTHORIZED,
        401,
        ErrorSeverity.MEDIUM,
        true,
        context,
        error
      )
    }

    if (error?.name === 'TokenExpiredError') {
      return new AppError(
        'Token expired',
        ErrorType.TOKEN_EXPIRED,
        401,
        ErrorSeverity.MEDIUM,
        true,
        context,
        error
      )
    }

    // Network Errors
    if (error?.code === 'ECONNREFUSED' || error?.code === 'ENOTFOUND') {
      return new AppError(
        'Connection error',
        ErrorType.CONNECTION_ERROR,
        503,
        ErrorSeverity.HIGH,
        true,
        context,
        error
      )
    }

    if (error?.code === 'ETIMEDOUT') {
      return new AppError(
        'Request timeout',
        ErrorType.TIMEOUT_ERROR,
        408,
        ErrorSeverity.MEDIUM,
        true,
        context,
        error
      )
    }

    // Azure OpenAI Errors
    if (error?.message?.includes('rate limit') || error?.status === 429) {
      return new AppError(
        'AI service rate limit exceeded',
        ErrorType.RATE_LIMIT_EXCEEDED,
        429,
        ErrorSeverity.MEDIUM,
        true,
        context,
        error
      )
    }

    if (error?.message?.includes('OpenAI') || error?.message?.includes('Azure')) {
      return new AppError(
        'AI service error',
        ErrorType.AI_SERVICE_ERROR,
        500,
        ErrorSeverity.HIGH,
        true,
        context,
        error
      )
    }

    // File Upload Errors
    if (error?.message?.includes('File too large')) {
      return new AppError(
        'File too large',
        ErrorType.FILE_TOO_LARGE,
        413,
        ErrorSeverity.LOW,
        true,
        context,
        error
      )
    }

    // Validation Errors
    if (error?.name === 'ValidationError' || error?.name === 'ZodError') {
      return new AppError(
        error.message || 'Validation error',
        ErrorType.VALIDATION_ERROR,
        400,
        ErrorSeverity.LOW,
        true,
        context,
        error
      )
    }

    // Default to internal error
    return new AppError(
      error?.message || 'An unexpected error occurred',
      ErrorType.INTERNAL_SERVER_ERROR,
      500,
      ErrorSeverity.HIGH,
      false,
      context,
      error
    )
  }
}

/**
 * Error Logger
 *
 * Provides intelligent error logging with different strategies
 * for development and production environments.
 *
 * Logging strategy:
 * - Development: Colored console output
 * - Production: Structured JSON output for external log services
 *
 * Filtering rules:
 * - Only logs operational errors or CRITICAL level errors
 * - Aggregates similar errors to avoid duplication
 *
 * Integration support:
 * - Sentry: Error monitoring and alerts
 * - LogRocket: User session recording
 * - CloudWatch: AWS logging service
 * - Custom log endpoints
 */
export class ErrorLogger {
  private static shouldLog(error: AppError): boolean {
    // Only log operational errors or high severity errors
    return error.isOperational || error.severity === ErrorSeverity.CRITICAL
  }

  static async log(error: AppError): Promise<void> {
    if (!this.shouldLog(error)) {
      return
    }

    const logEntry = error.toLogFormat()

    // Choose logging method based on environment
    if (process.env.NODE_ENV === 'production') {
      // Production: Send to logging service
      try {
        // Integrate with Sentry, LogRocket, or other logging services here
        // await sendToLogService(logEntry)
        console.error('PRODUCTION_ERROR:', JSON.stringify(logEntry, null, 2))
      } catch (logError) {
        console.error('Failed to log error to external service:', logError)
        console.error('Original error:', logEntry)
      }
    } else {
      // Development: Console output
      if (logEntry.level === 'error') {
        console.error(`[${logEntry.type}] ${logEntry.message}`, logEntry)
      } else if (logEntry.level === 'warn') {
        console.warn(`[${logEntry.type}] ${logEntry.message}`, logEntry)
      } else {
        console.info(`[${logEntry.type}] ${logEntry.message}`, logEntry)
      }
    }
  }

  /**
   * Batch log errors
   *
   * Used for analytics scenarios, logging multiple errors at once.
   * Suitable for batch operation failures, error statistics, etc.
   */
  static async logBatch(errors: AppError[]): Promise<void> {
    const loggableErrors = errors.filter(this.shouldLog)

    if (loggableErrors.length === 0) {
      return
    }

    const logEntries = loggableErrors.map(error => error.toLogFormat())

    if (process.env.NODE_ENV === 'production') {
      try {
        // await sendBatchToLogService(logEntries)
        console.error('BATCH_ERRORS:', JSON.stringify(logEntries, null, 2))
      } catch (logError) {
        console.error('Failed to log batch errors:', logError)
      }
    } else {
      console.group('Batch Error Log:')
      logEntries.forEach(entry => {
        console.log(`[${entry.type}] ${entry.message}`)
      })
      console.groupEnd()
    }
  }
}

/**
 * Create error context
 *
 * Extracts error context information from HTTP request for tracking.
 * Auto-generates request ID if not present.
 */
export function createErrorContext(request?: any): ErrorContext {
  return {
    requestId: request?.headers?.get('x-request-id') || generateRequestId(),
    path: request?.nextUrl?.pathname,
    method: request?.method,
    userAgent: request?.headers?.get('user-agent'),
    timestamp: new Date(),
  }
}

function generateRequestId(): string {
  return `req_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`
}

/**
 * Error Metrics Collector
 *
 * Collects and analyzes error metrics for system health monitoring
 * and error trend analysis.
 *
 * Features:
 * - Count errors by type
 * - Provide statistics within time ranges
 * - Support stat resets to avoid memory accumulation
 * - Integrate with monitoring dashboards
 *
 * @example
 * ```typescript
 * // Record error
 * ErrorMetrics.increment(ErrorType.DATABASE_ERROR)
 *
 * // Get statistics
 * const stats = ErrorMetrics.getStats()
 * console.log(`Total errors: ${stats.total}`)
 *
 * // Reset statistics (usually in scheduled tasks)
 * ErrorMetrics.reset()
 * ```
 *
 * Notes:
 * - Recommended to reset periodically to avoid memory leaks
 * - Consider external statistics service for high-traffic systems
 * - Statistics not persisted, will be lost on restart
 */
export class ErrorMetrics {
  private static errorCounts = new Map<string, number>()
  private static lastReset = new Date()

  static increment(errorType: ErrorType): void {
    const current = this.errorCounts.get(errorType) || 0
    this.errorCounts.set(errorType, current + 1)
  }

  static getStats(): {
    errors: Record<string, number>
    period: { start: Date; end: Date }
    total: number
  } {
    const errors: Record<string, number> = {}
    let total = 0

    this.errorCounts.forEach((count, type) => {
      errors[type] = count
      total += count
    })

    return {
      errors,
      period: {
        start: this.lastReset,
        end: new Date(),
      },
      total,
    }
  }

  static reset(): void {
    this.errorCounts.clear()
    this.lastReset = new Date()
  }
}
