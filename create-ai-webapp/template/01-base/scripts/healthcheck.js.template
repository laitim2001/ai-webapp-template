#!/usr/bin/env node
/**
 * {{PROJECT_NAME}} - å¥åº·æª¢æŸ¥è…³æœ¬
 * ç”¨æ–¼ Docker å¥åº·æª¢æŸ¥å’Œç³»çµ±ç›£æ§
 */

const http = require('http');
const { execSync } = require('child_process');

// ============================================
// é…ç½®
// ============================================

const CONFIG = {
  app: {
    host: process.env.HEALTH_CHECK_HOST || 'localhost',
    port: parseInt(process.env.PORT || '3000'),
    path: '/api/health',
    timeout: 5000,
  },
  database: {
    enabled: process.env.DATABASE_HEALTH_CHECK !== 'false',
    type: process.env.DATABASE_TYPE || 'postgresql',
  },
  redis: {
    enabled: process.env.REDIS_HEALTH_CHECK !== 'false',
    url: process.env.REDIS_URL,
  },
  verbose: process.env.HEALTH_CHECK_VERBOSE === 'true',
};

// ============================================
// å¥åº·æª¢æŸ¥å‡½æ•¸
// ============================================

/**
 * æª¢æŸ¥ HTTP ç«¯é»
 */
function checkHttpEndpoint() {
  return new Promise((resolve, reject) => {
    const options = {
      hostname: CONFIG.app.host,
      port: CONFIG.app.port,
      path: CONFIG.app.path,
      method: 'GET',
      timeout: CONFIG.app.timeout,
    };

    const req = http.request(options, (res) => {
      let data = '';

      res.on('data', (chunk) => {
        data += chunk;
      });

      res.on('end', () => {
        if (res.statusCode === 200) {
          try {
            const healthData = JSON.parse(data);
            resolve({
              status: 'healthy',
              statusCode: res.statusCode,
              data: healthData,
            });
          } catch (e) {
            resolve({
              status: 'healthy',
              statusCode: res.statusCode,
              data: { message: 'OK' },
            });
          }
        } else {
          reject(new Error(`HTTP ${res.statusCode}: ${data}`));
        }
      });
    });

    req.on('error', (error) => {
      reject(error);
    });

    req.on('timeout', () => {
      req.destroy();
      reject(new Error(`Request timeout after ${CONFIG.app.timeout}ms`));
    });

    req.end();
  });
}

/**
 * æª¢æŸ¥æ•¸æ“šåº«é€£æ¥
 */
function checkDatabase() {
  if (!CONFIG.database.enabled) {
    return Promise.resolve({ status: 'skipped', message: 'Database check disabled' });
  }

  const { type } = CONFIG.database;
  const databaseUrl = process.env.DATABASE_URL;

  if (!databaseUrl) {
    return Promise.reject(new Error('DATABASE_URL not configured'));
  }

  try {
    switch (type) {
      case 'postgresql': {
        const url = new URL(databaseUrl);
        const command = `PGPASSWORD="${url.password}" psql -h ${url.hostname} -p ${url.port || 5432} -U ${url.username} -d ${url.pathname.slice(1)} -c "SELECT 1" -t -A`;
        execSync(command, { stdio: 'pipe', timeout: 5000 });
        return Promise.resolve({ status: 'healthy', type: 'postgresql' });
      }

      case 'mysql': {
        const url = new URL(databaseUrl);
        const command = `mysql -h ${url.hostname} -P ${url.port || 3306} -u ${url.username} -p${url.password} -e "SELECT 1" ${url.pathname.slice(1)}`;
        execSync(command, { stdio: 'pipe', timeout: 5000 });
        return Promise.resolve({ status: 'healthy', type: 'mysql' });
      }

      case 'mongodb': {
        // MongoDB é€šé Prisma å¥åº·ç«¯é»æª¢æŸ¥
        return Promise.resolve({ status: 'checked_via_api', type: 'mongodb' });
      }

      case 'sqlite': {
        const fs = require('fs');
        const dbPath = databaseUrl.replace('file:', '');
        if (fs.existsSync(dbPath)) {
          return Promise.resolve({ status: 'healthy', type: 'sqlite' });
        }
        return Promise.reject(new Error(`SQLite database file not found: ${dbPath}`));
      }

      default:
        return Promise.reject(new Error(`Unsupported database type: ${type}`));
    }
  } catch (error) {
    return Promise.reject(error);
  }
}

/**
 * æª¢æŸ¥ Redis é€£æ¥
 */
function checkRedis() {
  if (!CONFIG.redis.enabled || !CONFIG.redis.url) {
    return Promise.resolve({ status: 'skipped', message: 'Redis check disabled or not configured' });
  }

  try {
    const command = `redis-cli -u "${CONFIG.redis.url}" ping`;
    const output = execSync(command, { stdio: 'pipe', timeout: 3000 }).toString().trim();

    if (output === 'PONG') {
      return Promise.resolve({ status: 'healthy' });
    }

    return Promise.reject(new Error(`Unexpected Redis response: ${output}`));
  } catch (error) {
    return Promise.reject(error);
  }
}

/**
 * æª¢æŸ¥ç³»çµ±è³‡æº
 */
function checkSystemResources() {
  try {
    const memUsage = process.memoryUsage();
    const cpuUsage = process.cpuUsage();

    return Promise.resolve({
      status: 'healthy',
      memory: {
        heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024),
        heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024),
        rss: Math.round(memUsage.rss / 1024 / 1024),
      },
      cpu: {
        user: cpuUsage.user,
        system: cpuUsage.system,
      },
      uptime: Math.round(process.uptime()),
    });
  } catch (error) {
    return Promise.reject(error);
  }
}

// ============================================
// ä¸»å‡½æ•¸
// ============================================

async function runHealthCheck() {
  const results = {
    timestamp: new Date().toISOString(),
    status: 'healthy',
    checks: {},
  };

  try {
    // 1. æª¢æŸ¥ HTTP ç«¯é» (ä¸»è¦æª¢æŸ¥)
    if (CONFIG.verbose) console.log('ğŸ” Checking HTTP endpoint...');
    const httpResult = await checkHttpEndpoint();
    results.checks.http = httpResult;
    if (CONFIG.verbose) console.log('âœ… HTTP endpoint healthy');

    // 2. æª¢æŸ¥æ•¸æ“šåº« (å¯é¸)
    if (CONFIG.database.enabled) {
      if (CONFIG.verbose) console.log('ğŸ” Checking database connection...');
      try {
        const dbResult = await checkDatabase();
        results.checks.database = dbResult;
        if (CONFIG.verbose) console.log('âœ… Database connection healthy');
      } catch (error) {
        results.checks.database = { status: 'unhealthy', error: error.message };
        if (CONFIG.verbose) console.error('âŒ Database check failed:', error.message);
      }
    }

    // 3. æª¢æŸ¥ Redis (å¯é¸)
    if (CONFIG.redis.enabled && CONFIG.redis.url) {
      if (CONFIG.verbose) console.log('ğŸ” Checking Redis connection...');
      try {
        const redisResult = await checkRedis();
        results.checks.redis = redisResult;
        if (CONFIG.verbose) console.log('âœ… Redis connection healthy');
      } catch (error) {
        results.checks.redis = { status: 'unhealthy', error: error.message };
        if (CONFIG.verbose) console.error('âŒ Redis check failed:', error.message);
      }
    }

    // 4. æª¢æŸ¥ç³»çµ±è³‡æº
    if (CONFIG.verbose) console.log('ğŸ” Checking system resources...');
    const systemResult = await checkSystemResources();
    results.checks.system = systemResult;
    if (CONFIG.verbose) console.log('âœ… System resources OK');

    // è¼¸å‡ºçµæœ
    if (CONFIG.verbose) {
      console.log('\nğŸ“Š Health Check Results:');
      console.log(JSON.stringify(results, null, 2));
    }

    // é€€å‡ºç‹€æ…‹ç¢¼ï¼š0 = å¥åº·
    process.exit(0);

  } catch (error) {
    results.status = 'unhealthy';
    results.error = error.message;

    if (CONFIG.verbose) {
      console.error('\nâŒ Health Check Failed:');
      console.error(JSON.stringify(results, null, 2));
      console.error('\nError details:', error);
    }

    // é€€å‡ºç‹€æ…‹ç¢¼ï¼š1 = ä¸å¥åº·
    process.exit(1);
  }
}

// ============================================
// CLI åƒæ•¸è™•ç†
// ============================================

function showUsage() {
  console.log(`
{{PROJECT_NAME}} - å¥åº·æª¢æŸ¥è…³æœ¬

ç”¨æ³•: node healthcheck.js [é¸é …]

é¸é …:
    -h, --help          é¡¯ç¤ºæ­¤å¹«åŠ©ä¿¡æ¯
    -v, --verbose       é¡¯ç¤ºè©³ç´°è¼¸å‡º
    --host <host>       æ‡‰ç”¨ä¸»æ©Ÿ (é»˜èª: localhost)
    --port <port>       æ‡‰ç”¨ç«¯å£ (é»˜èª: 3000)
    --no-db             è·³éæ•¸æ“šåº«æª¢æŸ¥
    --no-redis          è·³é Redis æª¢æŸ¥

ç’°å¢ƒè®Šæ•¸:
    PORT                        æ‡‰ç”¨ç«¯å£
    HEALTH_CHECK_HOST           å¥åº·æª¢æŸ¥ä¸»æ©Ÿ
    HEALTH_CHECK_VERBOSE        è©³ç´°è¼¸å‡º (true/false)
    DATABASE_HEALTH_CHECK       å•Ÿç”¨æ•¸æ“šåº«æª¢æŸ¥ (é»˜èª: true)
    DATABASE_TYPE               æ•¸æ“šåº«é¡å‹
    DATABASE_URL                æ•¸æ“šåº«é€£æ¥å­—ç¬¦ä¸²
    REDIS_HEALTH_CHECK          å•Ÿç”¨ Redis æª¢æŸ¥ (é»˜èª: true)
    REDIS_URL                   Redis é€£æ¥å­—ç¬¦ä¸²

ç¤ºä¾‹:
    node healthcheck.js                     # åŸºæœ¬å¥åº·æª¢æŸ¥
    node healthcheck.js -v                  # è©³ç´°è¼¸å‡º
    node healthcheck.js --no-db --no-redis  # åƒ…æª¢æŸ¥ HTTP ç«¯é»

é€€å‡ºç‹€æ…‹ç¢¼:
    0 - å¥åº·
    1 - ä¸å¥åº·
  `);
}

// è§£æ CLI åƒæ•¸
const args = process.argv.slice(2);
for (let i = 0; i < args.length; i++) {
  switch (args[i]) {
    case '-h':
    case '--help':
      showUsage();
      process.exit(0);
      break;
    case '-v':
    case '--verbose':
      CONFIG.verbose = true;
      break;
    case '--host':
      CONFIG.app.host = args[++i];
      break;
    case '--port':
      CONFIG.app.port = parseInt(args[++i]);
      break;
    case '--no-db':
      CONFIG.database.enabled = false;
      break;
    case '--no-redis':
      CONFIG.redis.enabled = false;
      break;
    default:
      console.error(`æœªçŸ¥é¸é …: ${args[i]}`);
      showUsage();
      process.exit(1);
  }
}

// åŸ·è¡Œå¥åº·æª¢æŸ¥
runHealthCheck();
