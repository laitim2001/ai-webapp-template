'use client'

/**
 * Collaboration Provider Component
 *
 * React context provider for real-time collaborative editing.
 * Manages WebSocket connections, synchronization, and user presence.
 *
 * @module CollaborationProvider
 */

import React, { createContext, useContext, useEffect, useState, useCallback, useRef } from 'react'
import { CollaborativeEditingService } from '@/lib/collaboration/collaborative-editing'
import { PresenceService } from '@/lib/collaboration/presence'
import type {
  CollaborationSession,
  UserPresence,
  CursorPosition,
  UserSelection,
  SyncStatus,
  EditorState
} from '@/types/collaboration'

interface CollaborationContextType {
  // Session management
  session: CollaborationSession | null
  isConnected: boolean
  syncStatus: SyncStatus

  // Document operations
  content: string
  updateContent: (content: string) => void
  applyChange: (position: number, content: string, type: 'insert' | 'delete' | 'replace') => void

  // Presence
  activeUsers: UserPresence[]
  currentUser: UserPresence | null
  updateCursor: (cursor: CursorPosition | null) => void
  updateSelection: (selection: UserSelection | null) => void
  setTyping: (isTyping: boolean) => void

  // Version control
  createVersion: (comment?: string) => Promise<void>
  currentVersion: number

  // Connection management
  connect: () => Promise<void>
  disconnect: () => Promise<void>
  reconnect: () => Promise<void>
}

const CollaborationContext = createContext<CollaborationContextType | null>(null)

interface CollaborationProviderProps {
  children: React.ReactNode
  documentId: string
  userId: string
  userName?: string
  userEmail?: string
  userAvatar?: string
  websocketUrl?: string
  autoConnect?: boolean
}

export function CollaborationProvider({
  children,
  documentId,
  userId,
  userName,
  userEmail,
  userAvatar,
  websocketUrl = 'ws://localhost:1234',
  autoConnect = true
}: CollaborationProviderProps) {
  // Services
  const editingServiceRef = useRef<CollaborativeEditingService>()
  const presenceServiceRef = useRef<PresenceService>()

  // State
  const [session, setSession] = useState<CollaborationSession | null>(null)
  const [isConnected, setIsConnected] = useState(false)
  const [syncStatus, setSyncStatus] = useState<SyncStatus>('disconnected')
  const [content, setContent] = useState('')
  const [activeUsers, setActiveUsers] = useState<UserPresence[]>([])
  const [currentUser, setCurrentUser] = useState<UserPresence | null>(null)
  const [currentVersion, setCurrentVersion] = useState(1)

  // Initialize services
  useEffect(() => {
    if (!editingServiceRef.current) {
      editingServiceRef.current = new CollaborativeEditingService(websocketUrl)
    }
    if (!presenceServiceRef.current) {
      presenceServiceRef.current = new PresenceService()
    }
  }, [websocketUrl])

  // Auto connect
  useEffect(() => {
    if (autoConnect && documentId && userId) {
      connect()
    }

    return () => {
      disconnect()
    }
  }, [documentId, userId, autoConnect])

  // Sync status polling
  useEffect(() => {
    if (!session) return

    const interval = setInterval(() => {
      const editingService = editingServiceRef.current
      if (editingService) {
        const status = editingService.getSyncStatus(session.id)
        setSyncStatus(status)
        setIsConnected(status === 'synced' || status === 'syncing')
      }

      const presenceService = presenceServiceRef.current
      if (presenceService) {
        const users = presenceService.getActiveUsers(documentId)
        setActiveUsers(users)
      }
    }, 1000)

    return () => clearInterval(interval)
  }, [session, documentId])

  // Content sync
  useEffect(() => {
    if (!session) return

    const interval = setInterval(() => {
      const editingService = editingServiceRef.current
      if (editingService) {
        const newContent = editingService.getDocumentContent(documentId)
        setContent(newContent)
      }
    }, 500)

    return () => clearInterval(interval)
  }, [session, documentId])

  /**
   * Connect to collaboration session
   */
  const connect = useCallback(async () => {
    if (!editingServiceRef.current || !presenceServiceRef.current) {
      console.error('Services not initialized')
      return
    }

    try {
      // Join or create session
      const newSession = await editingServiceRef.current.joinSession(
        documentId,
        userId
      )

      setSession(newSession)
      setCurrentVersion(newSession.version)

      // Get WebSocket provider
      const provider = (editingServiceRef.current as any).providers.get(documentId)

      if (provider) {
        // Initialize presence
        const presence = presenceServiceRef.current.initializePresence(
          userId,
          documentId,
          provider,
          {
            name: userName,
            email: userEmail,
            avatar: userAvatar
          }
        )

        setCurrentUser(presence)
      }

      // Get initial content
      const initialContent = editingServiceRef.current.getDocumentContent(documentId)
      setContent(initialContent)

      setIsConnected(true)
      setSyncStatus('syncing')
    } catch (error) {
      console.error('Failed to connect to collaboration session:', error)
      setIsConnected(false)
      setSyncStatus('disconnected')
    }
  }, [documentId, userId, userName, userEmail, userAvatar])

  /**
   * Disconnect from collaboration session
   */
  const disconnect = useCallback(async () => {
    if (!session || !editingServiceRef.current || !presenceServiceRef.current) return

    try {
      await editingServiceRef.current.leaveSession(session.id)
      presenceServiceRef.current.removePresence(userId)

      setSession(null)
      setIsConnected(false)
      setSyncStatus('disconnected')
      setCurrentUser(null)
    } catch (error) {
      console.error('Failed to disconnect from collaboration session:', error)
    }
  }, [session, userId])

  /**
   * Reconnect to collaboration session
   */
  const reconnect = useCallback(async () => {
    await disconnect()
    await connect()
  }, [disconnect, connect])

  /**
   * Update document content
   */
  const updateContent = useCallback((newContent: string) => {
    if (!editingServiceRef.current || !session) return

    // Calculate diff and apply changes
    // For simplicity, replace entire content
    const currentContent = content
    if (newContent !== currentContent) {
      editingServiceRef.current.applyChanges(documentId, userId, [
        {
          document_id: documentId,
          user_id: userId,
          type: 'replace',
          position: 0,
          length: currentContent.length,
          content: newContent,
          created_at: new Date()
        }
      ])
    }
  }, [content, documentId, userId, session])

  /**
   * Apply single change
   */
  const applyChange = useCallback((
    position: number,
    changeContent: string,
    type: 'insert' | 'delete' | 'replace'
  ) => {
    if (!editingServiceRef.current || !session) return

    editingServiceRef.current.applyChanges(documentId, userId, [
      {
        document_id: documentId,
        user_id: userId,
        type,
        position,
        content: changeContent,
        length: type === 'delete' ? changeContent.length : undefined,
        created_at: new Date()
      }
    ])
  }, [documentId, userId, session])

  /**
   * Update cursor position
   */
  const updateCursor = useCallback((cursor: CursorPosition | null) => {
    if (!presenceServiceRef.current) return
    presenceServiceRef.current.updateCursor(userId, cursor)
  }, [userId])

  /**
   * Update selection
   */
  const updateSelection = useCallback((selection: UserSelection | null) => {
    if (!presenceServiceRef.current) return
    presenceServiceRef.current.updateSelection(userId, selection)
  }, [userId])

  /**
   * Set typing status
   */
  const setTyping = useCallback((isTyping: boolean) => {
    if (!presenceServiceRef.current) return
    presenceServiceRef.current.updateTypingStatus(userId, isTyping)
  }, [userId])

  /**
   * Create new version
   */
  const createVersion = useCallback(async (comment?: string) => {
    if (!editingServiceRef.current || !session) return

    try {
      const version = await editingServiceRef.current.createVersion(
        documentId,
        userId,
        comment
      )
      setCurrentVersion(version.version)
    } catch (error) {
      console.error('Failed to create version:', error)
    }
  }, [documentId, userId, session])

  const value: CollaborationContextType = {
    session,
    isConnected,
    syncStatus,
    content,
    updateContent,
    applyChange,
    activeUsers,
    currentUser,
    updateCursor,
    updateSelection,
    setTyping,
    createVersion,
    currentVersion,
    connect,
    disconnect,
    reconnect
  }

  return (
    <CollaborationContext.Provider value={value}>
      {children}
    </CollaborationContext.Provider>
  )
}

/**
 * Hook to use collaboration context
 */
export function useCollaboration() {
  const context = useContext(CollaborationContext)
  if (!context) {
    throw new Error('useCollaboration must be used within CollaborationProvider')
  }
  return context
}

/**
 * Cursor overlay component
 */
export function CursorOverlay() {
  const { activeUsers, currentUser } = useCollaboration()

  const otherUsers = activeUsers.filter(u => u.userId !== currentUser?.userId)

  return (
    <div className="absolute inset-0 pointer-events-none">
      {otherUsers.map(user => {
        if (!user.cursor) return null

        return (
          <div
            key={user.userId}
            className="absolute w-0.5 h-5 transition-all duration-100"
            style={{
              left: `${user.cursor.x}px`,
              top: `${user.cursor.y}px`,
              backgroundColor: user.color
            }}
          >
            <div
              className="absolute -top-6 left-0 px-2 py-0.5 rounded text-xs text-white whitespace-nowrap"
              style={{ backgroundColor: user.color }}
            >
              {user.name}
            </div>
          </div>
        )
      })}
    </div>
  )
}

/**
 * Active users list component
 */
export function ActiveUsersList() {
  const { activeUsers, currentUser } = useCollaboration()

  return (
    <div className="flex items-center gap-2">
      <span className="text-sm text-gray-600">
        {activeUsers.length} user{activeUsers.length !== 1 ? 's' : ''} online
      </span>
      <div className="flex -space-x-2">
        {activeUsers.map(user => (
          <div
            key={user.userId}
            className="w-8 h-8 rounded-full border-2 border-white flex items-center justify-center text-white text-xs font-medium"
            style={{ backgroundColor: user.color }}
            title={user.name}
          >
            {user.avatar ? (
              <img
                src={user.avatar}
                alt={user.name}
                className="w-full h-full rounded-full object-cover"
              />
            ) : (
              <span>{user.name.charAt(0).toUpperCase()}</span>
            )}
            {user.isTyping && (
              <div className="absolute -bottom-1 -right-1 w-3 h-3 bg-green-500 rounded-full border border-white" />
            )}
          </div>
        ))}
      </div>
    </div>
  )
}

/**
 * Sync status indicator component
 */
export function SyncStatusIndicator() {
  const { syncStatus, isConnected } = useCollaboration()

  const statusConfig = {
    synced: { label: 'Synced', color: 'bg-green-500', icon: '✓' },
    syncing: { label: 'Syncing...', color: 'bg-yellow-500', icon: '⟳' },
    disconnected: { label: 'Disconnected', color: 'bg-red-500', icon: '✕' },
    connecting: { label: 'Connecting...', color: 'bg-blue-500', icon: '...' }
  }

  const config = statusConfig[syncStatus]

  return (
    <div className="flex items-center gap-2 text-sm">
      <div className={`w-2 h-2 rounded-full ${config.color}`} />
      <span className="text-gray-600">{config.label}</span>
    </div>
  )
}
