#!/bin/bash
# {{PROJECT_NAME}} - 數據庫恢復腳本
# 支持 PostgreSQL, MySQL, MongoDB 和 SQLite

set -e  # 遇到錯誤立即退出
set -u  # 使用未定義變數時報錯

# ============================================
# 配置區域
# ============================================

BACKUP_DIR="${BACKUP_DIR:-./backups}"
DATABASE_TYPE="${DATABASE_TYPE:-postgresql}"
BACKUP_FILE=""

# 根據數據庫類型設置變數
case "$DATABASE_TYPE" in
  postgresql)
    DB_HOST="${POSTGRES_HOST:-localhost}"
    DB_PORT="${POSTGRES_PORT:-5432}"
    DB_NAME="${POSTGRES_DB:-{{PROJECT_NAME}}}"
    DB_USER="${POSTGRES_USER:-postgres}"
    DB_PASSWORD="${POSTGRES_PASSWORD}"
    ;;
  mysql)
    DB_HOST="${MYSQL_HOST:-localhost}"
    DB_PORT="${MYSQL_PORT:-3306}"
    DB_NAME="${MYSQL_DB:-{{PROJECT_NAME}}}"
    DB_USER="${MYSQL_USER:-root}"
    DB_PASSWORD="${MYSQL_PASSWORD}"
    ;;
  mongodb)
    DB_HOST="${MONGO_HOST:-localhost}"
    DB_PORT="${MONGO_PORT:-27017}"
    DB_NAME="${MONGO_DB:-{{PROJECT_NAME}}}"
    DB_USER="${MONGO_USER:-admin}"
    DB_PASSWORD="${MONGO_PASSWORD}"
    ;;
  sqlite)
    SQLITE_DB_PATH="${SQLITE_DB_PATH:-./prisma/dev.db}"
    ;;
  *)
    echo "❌ 錯誤: 不支持的數據庫類型: $DATABASE_TYPE"
    exit 1
    ;;
esac

# ============================================
# 函數定義
# ============================================

# 顯示使用說明
show_usage() {
    cat << EOF
用法: $0 [選項] <備份文件>

選項:
    -h, --help              顯示此幫助信息
    -t, --type <type>       數據庫類型 (postgresql, mysql, mongodb, sqlite)
    -l, --list              列出可用的備份文件
    -y, --yes               自動確認 (跳過警告)

環境變數:
    DATABASE_TYPE           數據庫類型
    BACKUP_DIR              備份目錄
    DB_HOST / DB_PORT       數據庫主機和端口
    DB_NAME                 數據庫名稱
    DB_USER / DB_PASSWORD   數據庫憑證

示例:
    $0 -l                                       # 列出可用備份
    $0 backups/postgresql_db_20240101.sql.gz    # 恢復指定備份
    $0 -t mysql -y backups/mysql_db.sql.gz      # 自動確認恢復

⚠️ 警告: 恢復操作將覆蓋現有數據，請先備份當前數據！

EOF
}

# 列出可用的備份文件
list_backups() {
    echo "📋 可用的備份文件:"
    echo "======================================"

    if [ ! -d "$BACKUP_DIR" ] || [ -z "$(ls -A $BACKUP_DIR 2>/dev/null)" ]; then
        echo "⚠️  未找到備份文件"
        exit 0
    fi

    # 根據數據庫類型過濾備份文件
    case "$DATABASE_TYPE" in
        postgresql)
            PATTERN="postgresql_*.sql.gz"
            ;;
        mysql)
            PATTERN="mysql_*.sql.gz"
            ;;
        mongodb)
            PATTERN="mongodb_*.archive.gz"
            ;;
        sqlite)
            PATTERN="sqlite_*.db"
            ;;
    esac

    # 列出備份文件，按時間排序
    find "$BACKUP_DIR" -type f -name "$PATTERN" -printf "%T@ %p\n" | \
        sort -rn | \
        while read timestamp file; do
            size=$(du -h "$file" | cut -f1)
            date=$(date -d "@$timestamp" '+%Y-%m-%d %H:%M:%S')
            echo "📦 $(basename "$file")"
            echo "   大小: $size | 時間: $date"
            echo "   路徑: $file"
            echo ""
        done

    exit 0
}

# 確認恢復操作
confirm_restore() {
    echo ""
    echo "⚠️  警告: 恢復操作將覆蓋現有數據庫！"
    echo "======================================"
    echo "數據庫類型: $DATABASE_TYPE"
    echo "數據庫名稱: $DB_NAME"
    echo "備份文件: $BACKUP_FILE"
    echo "======================================"
    echo ""

    read -p "確認要恢復此備份嗎？(yes/no): " -r
    if [[ ! $REPLY =~ ^[Yy][Ee][Ss]$ ]]; then
        echo "❌ 取消恢復操作"
        exit 0
    fi
}

# PostgreSQL 恢復
restore_postgresql() {
    echo "🐘 開始 PostgreSQL 恢復..."

    # 設置密碼環境變數
    export PGPASSWORD="$DB_PASSWORD"

    # 終止所有連接到目標數據庫的活動會話
    psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d postgres -c \
        "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '$DB_NAME' AND pid <> pg_backend_pid();" || true

    # 刪除並重新創建數據庫
    dropdb -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" "$DB_NAME" --if-exists
    createdb -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" "$DB_NAME"

    # 恢復數據
    gunzip -c "$BACKUP_FILE" | pg_restore \
        -h "$DB_HOST" \
        -p "$DB_PORT" \
        -U "$DB_USER" \
        -d "$DB_NAME" \
        --verbose \
        --no-owner \
        --no-acl

    # 清除密碼環境變數
    unset PGPASSWORD

    echo "✅ PostgreSQL 恢復成功"
}

# MySQL 恢復
restore_mysql() {
    echo "🐬 開始 MySQL 恢復..."

    # 刪除並重新創建數據庫
    mysql -h "$DB_HOST" -P "$DB_PORT" -u "$DB_USER" -p"$DB_PASSWORD" -e \
        "DROP DATABASE IF EXISTS $DB_NAME; CREATE DATABASE $DB_NAME CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;"

    # 恢復數據
    gunzip -c "$BACKUP_FILE" | mysql \
        -h "$DB_HOST" \
        -P "$DB_PORT" \
        -u "$DB_USER" \
        -p"$DB_PASSWORD" \
        "$DB_NAME"

    echo "✅ MySQL 恢復成功"
}

# MongoDB 恢復
restore_mongodb() {
    echo "🍃 開始 MongoDB 恢復..."

    # 創建臨時目錄
    TEMP_DIR=$(mktemp -d)

    # 解壓備份
    tar -xzf "$BACKUP_FILE" -C "$TEMP_DIR"

    # 刪除現有數據庫
    mongo --host "$DB_HOST" --port "$DB_PORT" \
          --username "$DB_USER" --password "$DB_PASSWORD" \
          --authenticationDatabase admin \
          "$DB_NAME" --eval "db.dropDatabase();" || true

    # 恢復數據
    mongorestore \
        --host "$DB_HOST" \
        --port "$DB_PORT" \
        --username "$DB_USER" \
        --password "$DB_PASSWORD" \
        --db "$DB_NAME" \
        --gzip \
        "$TEMP_DIR/$DB_NAME"

    # 清理臨時目錄
    rm -rf "$TEMP_DIR"

    echo "✅ MongoDB 恢復成功"
}

# SQLite 恢復
restore_sqlite() {
    echo "💎 開始 SQLite 恢復..."

    if [ ! -f "$BACKUP_FILE" ]; then
        echo "❌ 錯誤: 備份文件不存在: $BACKUP_FILE"
        exit 1
    fi

    # 備份當前數據庫 (如果存在)
    if [ -f "$SQLITE_DB_PATH" ]; then
        CURRENT_BACKUP="${SQLITE_DB_PATH}.before_restore.$(date +%s)"
        echo "📦 備份當前數據庫到: $CURRENT_BACKUP"
        cp "$SQLITE_DB_PATH" "$CURRENT_BACKUP"
    fi

    # 恢復數據庫
    cp "$BACKUP_FILE" "$SQLITE_DB_PATH"

    echo "✅ SQLite 恢復成功"
}

# ============================================
# 主程序
# ============================================

main() {
    echo "🚀 {{PROJECT_NAME}} 數據庫恢復腳本"
    echo "======================================"

    # 檢查備份文件是否存在
    if [ ! -f "$BACKUP_FILE" ]; then
        echo "❌ 錯誤: 備份文件不存在: $BACKUP_FILE"
        exit 1
    fi

    # 確認恢復操作
    if [ "${AUTO_CONFIRM:-0}" != "1" ]; then
        confirm_restore
    fi

    # 根據數據庫類型執行恢復
    case "$DATABASE_TYPE" in
        postgresql)
            restore_postgresql
            ;;
        mysql)
            restore_mysql
            ;;
        mongodb)
            restore_mongodb
            ;;
        sqlite)
            restore_sqlite
            ;;
    esac

    echo "✅ 恢復流程完成"
}

# 解析命令行參數
AUTO_CONFIRM=0
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_usage
            exit 0
            ;;
        -t|--type)
            DATABASE_TYPE="$2"
            shift 2
            ;;
        -l|--list)
            list_backups
            ;;
        -y|--yes)
            AUTO_CONFIRM=1
            shift
            ;;
        *)
            if [ -z "$BACKUP_FILE" ]; then
                BACKUP_FILE="$1"
            else
                echo "❌ 未知選項: $1"
                show_usage
                exit 1
            fi
            shift
            ;;
    esac
done

# 檢查是否提供了備份文件
if [ -z "$BACKUP_FILE" ]; then
    echo "❌ 錯誤: 請指定備份文件"
    echo ""
    show_usage
    exit 1
fi

# 執行主程序
main
