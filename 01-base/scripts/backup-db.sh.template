#!/bin/bash
# {{PROJECT_NAME}} - 數據庫備份腳本
# 支持 PostgreSQL, MySQL, MongoDB 和 SQLite

set -e  # 遇到錯誤立即退出
set -u  # 使用未定義變數時報錯

# ============================================
# 配置區域
# ============================================

# 從環境變數讀取或使用默認值
BACKUP_DIR="${BACKUP_DIR:-./backups}"
RETENTION_DAYS="${RETENTION_DAYS:-7}"
DATABASE_TYPE="${DATABASE_TYPE:-postgresql}"  # postgresql, mysql, mongodb, sqlite
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")

# 根據數據庫類型設置變數
case "$DATABASE_TYPE" in
  postgresql)
    DB_HOST="${POSTGRES_HOST:-localhost}"
    DB_PORT="${POSTGRES_PORT:-5432}"
    DB_NAME="${POSTGRES_DB:-{{PROJECT_NAME}}}"
    DB_USER="${POSTGRES_USER:-postgres}"
    DB_PASSWORD="${POSTGRES_PASSWORD}"
    BACKUP_FILE="$BACKUP_DIR/postgresql_${DB_NAME}_${TIMESTAMP}.sql.gz"
    ;;
  mysql)
    DB_HOST="${MYSQL_HOST:-localhost}"
    DB_PORT="${MYSQL_PORT:-3306}"
    DB_NAME="${MYSQL_DB:-{{PROJECT_NAME}}}"
    DB_USER="${MYSQL_USER:-root}"
    DB_PASSWORD="${MYSQL_PASSWORD}"
    BACKUP_FILE="$BACKUP_DIR/mysql_${DB_NAME}_${TIMESTAMP}.sql.gz"
    ;;
  mongodb)
    DB_HOST="${MONGO_HOST:-localhost}"
    DB_PORT="${MONGO_PORT:-27017}"
    DB_NAME="${MONGO_DB:-{{PROJECT_NAME}}}"
    DB_USER="${MONGO_USER:-admin}"
    DB_PASSWORD="${MONGO_PASSWORD}"
    BACKUP_FILE="$BACKUP_DIR/mongodb_${DB_NAME}_${TIMESTAMP}.archive.gz"
    ;;
  sqlite)
    SQLITE_DB_PATH="${SQLITE_DB_PATH:-./prisma/dev.db}"
    BACKUP_FILE="$BACKUP_DIR/sqlite_${TIMESTAMP}.db"
    ;;
  *)
    echo "❌ 錯誤: 不支持的數據庫類型: $DATABASE_TYPE"
    echo "支持的類型: postgresql, mysql, mongodb, sqlite"
    exit 1
    ;;
esac

# ============================================
# 函數定義
# ============================================

# 顯示使用說明
show_usage() {
    cat << EOF
用法: $0 [選項]

選項:
    -h, --help              顯示此幫助信息
    -t, --type <type>       數據庫類型 (postgresql, mysql, mongodb, sqlite)
    -d, --dir <directory>   備份目錄 (默認: ./backups)
    -r, --retention <days>  保留天數 (默認: 7)

環境變數:
    DATABASE_TYPE           數據庫類型
    BACKUP_DIR              備份目錄
    RETENTION_DAYS          保留天數
    DB_HOST / DB_PORT       數據庫主機和端口
    DB_NAME                 數據庫名稱
    DB_USER / DB_PASSWORD   數據庫憑證

示例:
    $0                                          # 使用默認配置
    $0 -t postgresql -d /backups -r 14          # 自定義配置
    DATABASE_TYPE=mysql $0                      # 使用環境變數

EOF
}

# 創建備份目錄
create_backup_dir() {
    if [ ! -d "$BACKUP_DIR" ]; then
        echo "📁 創建備份目錄: $BACKUP_DIR"
        mkdir -p "$BACKUP_DIR"
    fi
}

# PostgreSQL 備份
backup_postgresql() {
    echo "🐘 開始 PostgreSQL 備份..."

    # 設置密碼環境變數
    export PGPASSWORD="$DB_PASSWORD"

    # 執行備份
    pg_dump \
        -h "$DB_HOST" \
        -p "$DB_PORT" \
        -U "$DB_USER" \
        -d "$DB_NAME" \
        --format=custom \
        --compress=9 \
        --verbose \
        | gzip > "$BACKUP_FILE"

    # 清除密碼環境變數
    unset PGPASSWORD

    if [ -f "$BACKUP_FILE" ]; then
        echo "✅ PostgreSQL 備份成功: $BACKUP_FILE"
    else
        echo "❌ PostgreSQL 備份失敗"
        exit 1
    fi
}

# MySQL 備份
backup_mysql() {
    echo "🐬 開始 MySQL 備份..."

    mysqldump \
        -h "$DB_HOST" \
        -P "$DB_PORT" \
        -u "$DB_USER" \
        -p"$DB_PASSWORD" \
        --single-transaction \
        --routines \
        --triggers \
        --events \
        "$DB_NAME" \
        | gzip > "$BACKUP_FILE"

    if [ -f "$BACKUP_FILE" ]; then
        echo "✅ MySQL 備份成功: $BACKUP_FILE"
    else
        echo "❌ MySQL 備份失敗"
        exit 1
    fi
}

# MongoDB 備份
backup_mongodb() {
    echo "🍃 開始 MongoDB 備份..."

    # 創建臨時目錄
    TEMP_DIR=$(mktemp -d)

    mongodump \
        --host "$DB_HOST" \
        --port "$DB_PORT" \
        --username "$DB_USER" \
        --password "$DB_PASSWORD" \
        --db "$DB_NAME" \
        --out "$TEMP_DIR" \
        --gzip

    # 打包備份
    tar -czf "$BACKUP_FILE" -C "$TEMP_DIR" .

    # 清理臨時目錄
    rm -rf "$TEMP_DIR"

    if [ -f "$BACKUP_FILE" ]; then
        echo "✅ MongoDB 備份成功: $BACKUP_FILE"
    else
        echo "❌ MongoDB 備份失敗"
        exit 1
    fi
}

# SQLite 備份
backup_sqlite() {
    echo "💎 開始 SQLite 備份..."

    if [ ! -f "$SQLITE_DB_PATH" ]; then
        echo "❌ 錯誤: SQLite 數據庫文件不存在: $SQLITE_DB_PATH"
        exit 1
    fi

    # 使用 SQLite 的備份命令 (確保數據一致性)
    sqlite3 "$SQLITE_DB_PATH" ".backup '$BACKUP_FILE'"

    if [ -f "$BACKUP_FILE" ]; then
        echo "✅ SQLite 備份成功: $BACKUP_FILE"
    else
        echo "❌ SQLite 備份失敗"
        exit 1
    fi
}

# 清理舊備份
cleanup_old_backups() {
    echo "🧹 清理 $RETENTION_DAYS 天前的舊備份..."

    find "$BACKUP_DIR" -type f -name "*.*" -mtime +$RETENTION_DAYS -print -delete

    echo "✅ 清理完成"
}

# 顯示備份信息
show_backup_info() {
    BACKUP_SIZE=$(du -h "$BACKUP_FILE" | cut -f1)

    echo ""
    echo "======================================"
    echo "📦 備份信息"
    echo "======================================"
    echo "數據庫類型: $DATABASE_TYPE"
    echo "數據庫名稱: $DB_NAME"
    echo "備份文件: $BACKUP_FILE"
    echo "文件大小: $BACKUP_SIZE"
    echo "備份時間: $(date '+%Y-%m-%d %H:%M:%S')"
    echo "======================================"
}

# ============================================
# 主程序
# ============================================

main() {
    echo "🚀 {{PROJECT_NAME}} 數據庫備份腳本"
    echo "======================================"

    # 創建備份目錄
    create_backup_dir

    # 根據數據庫類型執行備份
    case "$DATABASE_TYPE" in
        postgresql)
            backup_postgresql
            ;;
        mysql)
            backup_mysql
            ;;
        mongodb)
            backup_mongodb
            ;;
        sqlite)
            backup_sqlite
            ;;
    esac

    # 清理舊備份
    cleanup_old_backups

    # 顯示備份信息
    show_backup_info

    echo "✅ 備份流程完成"
}

# 解析命令行參數
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_usage
            exit 0
            ;;
        -t|--type)
            DATABASE_TYPE="$2"
            shift 2
            ;;
        -d|--dir)
            BACKUP_DIR="$2"
            shift 2
            ;;
        -r|--retention)
            RETENTION_DAYS="$2"
            shift 2
            ;;
        *)
            echo "❌ 未知選項: $1"
            show_usage
            exit 1
            ;;
    esac
done

# 執行主程序
main
