/**
 * Role-Based Access Control (RBAC) System
 *
 * Provides enterprise-grade role and permission management with:
 * - Role hierarchy and inheritance
 * - Resource-level permissions
 * - Operation-level access control
 * - Dynamic permission evaluation
 *
 * @module Security/RBAC
 */

import { databaseAdapter } from '@/lib/db/database-adapter';

// ============================================================================
// Type Definitions
// ============================================================================

export enum Role {
  ADMIN = 'ADMIN',
  SALES_MANAGER = 'SALES_MANAGER',
  SALES_REP = 'SALES_REP',
  USER = 'USER',
}

export enum Permission {
  // Customer permissions
  CREATE_CUSTOMER = 'create:customer',
  READ_CUSTOMER = 'read:customer',
  UPDATE_CUSTOMER = 'update:customer',
  DELETE_CUSTOMER = 'delete:customer',

  // Knowledge base permissions
  CREATE_KNOWLEDGE = 'create:knowledge',
  READ_KNOWLEDGE = 'read:knowledge',
  UPDATE_KNOWLEDGE = 'update:knowledge',
  DELETE_KNOWLEDGE = 'delete:knowledge',
  MANAGE_KNOWLEDGE = 'manage:knowledge',

  // Workflow permissions
  CREATE_WORKFLOW = 'create:workflow',
  READ_WORKFLOW = 'read:workflow',
  UPDATE_WORKFLOW = 'update:workflow',
  DELETE_WORKFLOW = 'delete:workflow',
  APPROVE_WORKFLOW = 'approve:workflow',

  // User management permissions
  CREATE_USER = 'create:user',
  READ_USER = 'read:user',
  UPDATE_USER = 'update:user',
  DELETE_USER = 'delete:user',
  MANAGE_ROLES = 'manage:roles',

  // Analytics permissions
  VIEW_ANALYTICS = 'view:analytics',
  EXPORT_DATA = 'export:data',

  // System permissions
  MANAGE_SYSTEM = 'manage:system',
  VIEW_AUDIT_LOG = 'view:audit_log',
}

export type Action = 'create' | 'read' | 'update' | 'delete' | 'manage' | 'approve' | 'view' | 'export';
export type Resource = 'customer' | 'knowledge' | 'workflow' | 'user' | 'analytics' | 'system' | 'audit_log';

export interface PermissionCheck {
  userId: string;
  action: Action;
  resource: Resource;
  resourceId?: string;
  context?: Record<string, any>;
}

export interface RoleDefinition {
  role: Role;
  permissions: Permission[];
  inherits?: Role[];
  description: string;
}

// ============================================================================
// Role Hierarchy Configuration
// ============================================================================

const ROLE_HIERARCHY: Record<Role, RoleDefinition> = {
  [Role.ADMIN]: {
    role: Role.ADMIN,
    description: 'System administrator with full access',
    permissions: [
      // All permissions
      ...Object.values(Permission),
    ],
    inherits: [],
  },

  [Role.SALES_MANAGER]: {
    role: Role.SALES_MANAGER,
    description: 'Sales team manager with elevated permissions',
    permissions: [
      // Customer management
      Permission.CREATE_CUSTOMER,
      Permission.READ_CUSTOMER,
      Permission.UPDATE_CUSTOMER,
      Permission.DELETE_CUSTOMER,

      // Knowledge base
      Permission.CREATE_KNOWLEDGE,
      Permission.READ_KNOWLEDGE,
      Permission.UPDATE_KNOWLEDGE,
      Permission.DELETE_KNOWLEDGE,
      Permission.MANAGE_KNOWLEDGE,

      // Workflow management
      Permission.CREATE_WORKFLOW,
      Permission.READ_WORKFLOW,
      Permission.UPDATE_WORKFLOW,
      Permission.APPROVE_WORKFLOW,

      // Team management
      Permission.READ_USER,
      Permission.UPDATE_USER,

      // Analytics
      Permission.VIEW_ANALYTICS,
      Permission.EXPORT_DATA,

      // Audit
      Permission.VIEW_AUDIT_LOG,
    ],
    inherits: [Role.SALES_REP],
  },

  [Role.SALES_REP]: {
    role: Role.SALES_REP,
    description: 'Sales representative with customer management',
    permissions: [
      // Customer operations
      Permission.CREATE_CUSTOMER,
      Permission.READ_CUSTOMER,
      Permission.UPDATE_CUSTOMER,

      // Knowledge base access
      Permission.READ_KNOWLEDGE,
      Permission.CREATE_KNOWLEDGE,

      // Workflow participation
      Permission.CREATE_WORKFLOW,
      Permission.READ_WORKFLOW,
      Permission.UPDATE_WORKFLOW,

      // Self management
      Permission.READ_USER,

      // Analytics viewing
      Permission.VIEW_ANALYTICS,
    ],
    inherits: [Role.USER],
  },

  [Role.USER]: {
    role: Role.USER,
    description: 'Basic user with read-only access',
    permissions: [
      // Read-only access
      Permission.READ_CUSTOMER,
      Permission.READ_KNOWLEDGE,
      Permission.READ_WORKFLOW,
      Permission.READ_USER,
    ],
    inherits: [],
  },
};

// ============================================================================
// Permission Matrix
// ============================================================================

/**
 * Build complete permission matrix with role inheritance
 */
function buildPermissionMatrix(): Map<Role, Set<Permission>> {
  const matrix = new Map<Role, Set<Permission>>();

  // Build permissions for each role including inherited permissions
  for (const [role, definition] of Object.entries(ROLE_HIERARCHY)) {
    const permissions = new Set<Permission>(definition.permissions);

    // Add inherited permissions
    if (definition.inherits) {
      for (const inheritedRole of definition.inherits) {
        const inheritedPerms = matrix.get(inheritedRole);
        if (inheritedPerms) {
          inheritedPerms.forEach(p => permissions.add(p));
        }
      }
    }

    matrix.set(role as Role, permissions);
  }

  return matrix;
}

const PERMISSION_MATRIX = buildPermissionMatrix();

// ============================================================================
// Core RBAC Functions
// ============================================================================

/**
 * Get user's role from database
 */
export async function getUserRole(userId: string): Promise<Role | null> {
  try {
    const user = await databaseAdapter.findUnique('user', {
      where: { id: userId },
      select: { role: true },
    });

    return user?.role as Role || null;
  } catch (error) {
    console.error('Error fetching user role:', error);
    return null;
  }
}

/**
 * Get all permissions for a role (including inherited)
 */
export function getRolePermissions(role: Role): Permission[] {
  const permissions = PERMISSION_MATRIX.get(role);
  return permissions ? Array.from(permissions) : [];
}

/**
 * Check if a role has a specific permission
 */
export function roleHasPermission(role: Role, permission: Permission): boolean {
  const permissions = PERMISSION_MATRIX.get(role);
  return permissions ? permissions.has(permission) : false;
}

/**
 * Check if a user has a specific permission
 */
export async function userHasPermission(
  userId: string,
  permission: Permission
): Promise<boolean> {
  const role = await getUserRole(userId);
  if (!role) return false;

  return roleHasPermission(role, permission);
}

/**
 * Check if a user can perform an action on a resource
 */
export async function checkPermission(
  userId: string,
  action: Action,
  resource: Resource,
  resourceId?: string
): Promise<boolean> {
  const role = await getUserRole(userId);
  if (!role) return false;

  // Build permission string (e.g., "read:customer")
  const permission = `${action}:${resource}` as Permission;

  // Check basic permission
  const hasPermission = roleHasPermission(role, permission);
  if (!hasPermission) return false;

  // If checking specific resource, verify ownership/access
  if (resourceId) {
    return await checkResourceAccess(userId, role, resource, resourceId);
  }

  return true;
}

/**
 * Check if user has access to a specific resource instance
 */
async function checkResourceAccess(
  userId: string,
  role: Role,
  resource: Resource,
  resourceId: string
): Promise<boolean> {
  // Admin has access to everything
  if (role === Role.ADMIN) return true;

  try {
    switch (resource) {
      case 'customer':
        // Check if user owns or is assigned to customer
        const customer = await databaseAdapter.findUnique('customer', {
          where: { id: resourceId },
          select: { ownerId: true, assignedUsers: true },
        });
        return customer?.ownerId === userId ||
               customer?.assignedUsers?.includes(userId) ||
               false;

      case 'workflow':
        // Check if user is workflow creator or participant
        const workflow = await databaseAdapter.findUnique('workflowInstance', {
          where: { id: resourceId },
          select: { createdBy: true, assignedTo: true },
        });
        return workflow?.createdBy === userId ||
               workflow?.assignedTo === userId ||
               false;

      case 'knowledge':
        // Knowledge base is generally accessible to all authenticated users
        return true;

      default:
        return false;
    }
  } catch (error) {
    console.error('Error checking resource access:', error);
    return false;
  }
}

/**
 * Require specific role(s) - throws error if not authorized
 */
export async function requireRole(
  userId: string,
  allowedRoles: Role[]
): Promise<void> {
  const userRole = await getUserRole(userId);

  if (!userRole || !allowedRoles.includes(userRole)) {
    throw new Error('Unauthorized: Insufficient permissions');
  }
}

/**
 * Require specific permission - throws error if not authorized
 */
export async function requirePermission(
  userId: string,
  permission: Permission
): Promise<void> {
  const hasPermission = await userHasPermission(userId, permission);

  if (!hasPermission) {
    throw new Error(`Unauthorized: Missing permission ${permission}`);
  }
}

/**
 * Get all roles that have a specific permission
 */
export function getRolesWithPermission(permission: Permission): Role[] {
  const roles: Role[] = [];

  for (const [role, permissions] of PERMISSION_MATRIX.entries()) {
    if (permissions.has(permission)) {
      roles.push(role);
    }
  }

  return roles;
}

/**
 * Check if a role inherits from another role
 */
export function roleInheritsFrom(role: Role, parentRole: Role): boolean {
  const definition = ROLE_HIERARCHY[role];
  if (!definition.inherits) return false;

  if (definition.inherits.includes(parentRole)) return true;

  // Check transitive inheritance
  for (const inherited of definition.inherits) {
    if (roleInheritsFrom(inherited, parentRole)) return true;
  }

  return false;
}

/**
 * Get role hierarchy for a role (including all inherited roles)
 */
export function getRoleHierarchy(role: Role): Role[] {
  const hierarchy: Role[] = [role];
  const definition = ROLE_HIERARCHY[role];

  if (definition.inherits) {
    for (const inherited of definition.inherits) {
      hierarchy.push(...getRoleHierarchy(inherited));
    }
  }

  return Array.from(new Set(hierarchy));
}

// ============================================================================
// Middleware Helpers
// ============================================================================

/**
 * Create middleware function that requires specific roles
 */
export function createRoleMiddleware(allowedRoles: Role[]) {
  return async (userId: string) => {
    await requireRole(userId, allowedRoles);
  };
}

/**
 * Create middleware function that requires specific permission
 */
export function createPermissionMiddleware(permission: Permission) {
  return async (userId: string) => {
    await requirePermission(userId, permission);
  };
}

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * Get human-readable role name
 */
export function getRoleName(role: Role): string {
  return ROLE_HIERARCHY[role]?.description || role;
}

/**
 * Get all available roles
 */
export function getAllRoles(): RoleDefinition[] {
  return Object.values(ROLE_HIERARCHY);
}

/**
 * Parse permission string into action and resource
 */
export function parsePermission(permission: Permission): { action: Action; resource: Resource } {
  const [action, resource] = permission.split(':');
  return { action: action as Action, resource: resource as Resource };
}
